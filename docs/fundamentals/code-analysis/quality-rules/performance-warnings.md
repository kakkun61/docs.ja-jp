---
title: パフォーマンスルール (コード分析)
description: コード分析のパフォーマンス規則について説明します。
ms.date: 11/04/2016
ms.topic: reference
f1_keywords:
- vs.codeanalysis.performancerules
helpviewer_keywords:
- rules, performance
- performance rules
- performance, rules
- managed code analysis rules, performance rules
author: gewarren
ms.author: gewarren
ms.openlocfilehash: 4409cc46eb73f13f8e59d7a51899da27035bb6af
ms.sourcegitcommit: 2e4adc490c1d2a705a0592b295d606b10b9f51f1
ms.translationtype: MT
ms.contentlocale: ja-JP
ms.lasthandoff: 09/25/2020
ms.locfileid: "96591192"
---
# <a name="performance-rules"></a><span data-ttu-id="f3334-103">パフォーマンス ルール</span><span class="sxs-lookup"><span data-stu-id="f3334-103">Performance rules</span></span>

<span data-ttu-id="f3334-104">パフォーマンスルールは、高パフォーマンスのライブラリとアプリケーションをサポートします。</span><span class="sxs-lookup"><span data-stu-id="f3334-104">Performance rules support high-performance libraries and applications.</span></span>

## <a name="in-this-section"></a><span data-ttu-id="f3334-105">このセクションの内容</span><span class="sxs-lookup"><span data-stu-id="f3334-105">In this section</span></span>

| <span data-ttu-id="f3334-106">ルール</span><span class="sxs-lookup"><span data-stu-id="f3334-106">Rule</span></span> | <span data-ttu-id="f3334-107">説明</span><span class="sxs-lookup"><span data-stu-id="f3334-107">Description</span></span> |
| - | - |
| [<span data-ttu-id="f3334-108">CA1802:適切な場所にリテラルを使用します</span><span class="sxs-lookup"><span data-stu-id="f3334-108">CA1802: Use Literals Where Appropriate</span></span>](ca1802.md) | <span data-ttu-id="f3334-109">フィールドが静的および読み取り専用として宣言されており (Visual Basic では Shared および ReadOnly)、コンパイル時に計算できるである値で初期化されています。</span><span class="sxs-lookup"><span data-stu-id="f3334-109">A field is declared static and read-only (Shared and ReadOnly in Visual Basic), and is initialized with a value that is computable at compile time.</span></span> <span data-ttu-id="f3334-110">対象のフィールドに割り当てられた値はコンパイル時に計算できるであるため、宣言を const (Visual Basic) フィールドに変更して、実行時ではなくコンパイル時に値が計算されるようにします。</span><span class="sxs-lookup"><span data-stu-id="f3334-110">Because the value that is assigned to the targeted field is computable at compile time, change the declaration to a const (Const in Visual Basic) field so that the value is computed at compile time instead of at run time.</span></span> |
| [<span data-ttu-id="f3334-111">CA1805: 不必要に初期化しないでください</span><span class="sxs-lookup"><span data-stu-id="f3334-111">CA1805: Do not initialize unnecessarily</span></span>](ca1805.md) | <span data-ttu-id="f3334-112">.NET ランタイムは、コンストラクターを実行する前に、参照型のすべてのフィールドを既定値に初期化します。</span><span class="sxs-lookup"><span data-stu-id="f3334-112">The .NET runtime initializes all fields of reference types to their default values before running the constructor.</span></span> <span data-ttu-id="f3334-113">ほとんどの場合、フィールドを既定値に明示的に初期化することは冗長であり、メンテナンスコストがかかり、パフォーマンスが低下する可能性があります (アセンブリサイズの増加など)。</span><span class="sxs-lookup"><span data-stu-id="f3334-113">In most cases, explicitly initializing a field to its default value is redundant, which adds to maintenance costs and may degrade performance (such as with increased assembly size).</span></span> |
| [<span data-ttu-id="f3334-114">CA1806:メソッドの結果を無視しない</span><span class="sxs-lookup"><span data-stu-id="f3334-114">CA1806: Do not ignore method results</span></span>](ca1806.md) | <span data-ttu-id="f3334-115">新しいオブジェクトが作成されましたが、使用されていないか、新しい文字列を作成して返すメソッドが呼び出され、新しい文字列が使用されていないか、またはコンポーネントオブジェクトモデル (COM) または P/Invoke メソッドが、使用されていない HRESULT またはエラーコードを返しています。</span><span class="sxs-lookup"><span data-stu-id="f3334-115">A new object is created but never used, or a method that creates and returns a new string is called and the new string is never used, or a Component Object Model (COM) or P/Invoke method returns an HRESULT or error code that is never used.</span></span> |
| [<span data-ttu-id="f3334-116">CA1810:参照型の静的フィールドをインラインで初期化します</span><span class="sxs-lookup"><span data-stu-id="f3334-116">CA1810: Initialize reference type static fields inline</span></span>](ca1810.md) | <span data-ttu-id="f3334-117">型で明示的な静的コンストラクターを宣言すると、Just-In-Time (JIT) コンパイラが、静的コンストラクターが呼び出されたことを確認するために、型の静的メソッドと静的インスタンス コンストラクターに個別にチェックを追加します。</span><span class="sxs-lookup"><span data-stu-id="f3334-117">When a type declares an explicit static constructor, the just-in-time (JIT) compiler adds a check to each static method and instance constructor of the type to make sure that the static constructor was previously called.</span></span> <span data-ttu-id="f3334-118">静的コンストラクターのチェックによってパフォーマンスが低下することがあります。</span><span class="sxs-lookup"><span data-stu-id="f3334-118">Static constructor checks can decrease performance.</span></span> |
| [<span data-ttu-id="f3334-119">CA1812:インスタンス化されていない内部クラスを使用しません</span><span class="sxs-lookup"><span data-stu-id="f3334-119">CA1812: Avoid uninstantiated internal classes</span></span>](ca1812.md) | <span data-ttu-id="f3334-120">アセンブリ レベルの型のインスタンスが、アセンブリ内のコードから作成されません。</span><span class="sxs-lookup"><span data-stu-id="f3334-120">An instance of an assembly-level type is not created by code in the assembly.</span></span> |
| [<span data-ttu-id="f3334-121">CA1813:アンシールド属性を使用しません</span><span class="sxs-lookup"><span data-stu-id="f3334-121">CA1813: Avoid unsealed attributes</span></span>](ca1813.md) | <span data-ttu-id="f3334-122">.NET には、カスタム属性を取得するためのメソッドが用意されています。</span><span class="sxs-lookup"><span data-stu-id="f3334-122">.NET provides methods for retrieving custom attributes.</span></span> <span data-ttu-id="f3334-123">既定では、これらのメソッドで属性の継承階層が検索されます。</span><span class="sxs-lookup"><span data-stu-id="f3334-123">By default, these methods search the attribute inheritance hierarchy.</span></span> <span data-ttu-id="f3334-124">属性をシールすると、継承階層の全体が検索されなくなるため、パフォーマンスが向上します。</span><span class="sxs-lookup"><span data-stu-id="f3334-124">Sealing the attribute eliminates the search through the inheritance hierarchy and can improve performance.</span></span> |
| [<span data-ttu-id="f3334-125">CA1814:複数次元の配列ではなくジャグ配列を使用します</span><span class="sxs-lookup"><span data-stu-id="f3334-125">CA1814: Prefer jagged arrays over multidimensional</span></span>](ca1814.md) | <span data-ttu-id="f3334-126">ジャグ配列とは、その要素も配列である配列です。</span><span class="sxs-lookup"><span data-stu-id="f3334-126">A jagged array is an array whose elements are arrays.</span></span> <span data-ttu-id="f3334-127">要素を構成する配列のサイズは異なる可能性があるため、一部のデータセットで無駄な領域が生じる可能性があります。</span><span class="sxs-lookup"><span data-stu-id="f3334-127">The arrays that make up the elements can be of different sizes, which can result in less wasted space for some sets of data.</span></span> |
| [<span data-ttu-id="f3334-128">CA1815:equals および operator equals を値型でオーバーライドします</span><span class="sxs-lookup"><span data-stu-id="f3334-128">CA1815: Override equals and operator equals on value types</span></span>](ca1815.md) | <span data-ttu-id="f3334-129">値型の場合、Equals を継承した実装が Reflection ライブラリを使用して、すべてのフィールドの内容を比較します。</span><span class="sxs-lookup"><span data-stu-id="f3334-129">For value types, the inherited implementation of Equals uses the Reflection library and compares the contents of all fields.</span></span> <span data-ttu-id="f3334-130">Reflection は計算コストが高いため、場合によってはすべてのフィールドで等値性を比較する必要はありません。</span><span class="sxs-lookup"><span data-stu-id="f3334-130">Reflection is computationally expensive, and comparing every field for equality might be unnecessary.</span></span> <span data-ttu-id="f3334-131">ユーザーがインスタンスの比較または並べ替えを行うことや、ハッシュ テーブル キーとしてインスタンスを使用することが予想される場合には、値型に Equals を実装する必要があります。</span><span class="sxs-lookup"><span data-stu-id="f3334-131">If you expect users to compare or sort instances, or to use instances as hash table keys, your value type should implement Equals.</span></span> |
| [<span data-ttu-id="f3334-132">CA1819:プロパティは、配列を返すことはできません</span><span class="sxs-lookup"><span data-stu-id="f3334-132">CA1819: Properties should not return arrays</span></span>](ca1819.md) | <span data-ttu-id="f3334-133">プロパティが読み取り専用の場合でも、プロパティによって返される配列は書き込み禁止になりません。</span><span class="sxs-lookup"><span data-stu-id="f3334-133">Arrays that are returned by properties are not write-protected, even if the property is read-only.</span></span> <span data-ttu-id="f3334-134">配列の改ざんを防ぐには、プロパティで配列のコピーを返す必要があります。</span><span class="sxs-lookup"><span data-stu-id="f3334-134">To keep the array tamper-proof, the property must return a copy of the array.</span></span> <span data-ttu-id="f3334-135">一般に、このようなプロパティを呼び出すときのパフォーマンス低下は理解されません。</span><span class="sxs-lookup"><span data-stu-id="f3334-135">Typically, users will not understand the adverse performance implications of calling such a property.</span></span> |
| [<span data-ttu-id="f3334-136">CA1820:文字列の長さを使用して空の文字列をテストします</span><span class="sxs-lookup"><span data-stu-id="f3334-136">CA1820: Test for empty strings using string length</span></span>](ca1820.md) | <span data-ttu-id="f3334-137">String.Length プロパティまたは String.IsNullOrEmpty メソッドを使用して文字列を比較する方法は、Equals を使用する場合よりもはるかに高速です。</span><span class="sxs-lookup"><span data-stu-id="f3334-137">Comparing strings by using the String.Length property or the String.IsNullOrEmpty method is significantly faster than using Equals.</span></span> |
| [<span data-ttu-id="f3334-138">CA1821:空のファイナライザーを削除します</span><span class="sxs-lookup"><span data-stu-id="f3334-138">CA1821: Remove empty finalizers</span></span>](ca1821.md) | <span data-ttu-id="f3334-139">オブジェクトの有効期間の追跡に関連するパフォーマンス オーバーヘッドが増大するため、ファイナライザーは可能な限り使用しないでください。</span><span class="sxs-lookup"><span data-stu-id="f3334-139">Whenever you can, avoid finalizers because of the additional performance overhead that is involved in tracking object lifetime.</span></span> <span data-ttu-id="f3334-140">空のファイナライザーを使用すると、追加のオーバーヘッドが発生します。</span><span class="sxs-lookup"><span data-stu-id="f3334-140">An empty finalizer incurs added overhead without any benefit.</span></span> |
| [<span data-ttu-id="f3334-141">CA1822:メンバーを static に設定します</span><span class="sxs-lookup"><span data-stu-id="f3334-141">CA1822: Mark members as static</span></span>](ca1822.md) | <span data-ttu-id="f3334-142">インスタンスデータにアクセスしたりインスタンスメソッドを呼び出したりしないメンバーは、静的としてマークできます (Visual Basic では Shared)。</span><span class="sxs-lookup"><span data-stu-id="f3334-142">Members that do not access instance data or call instance methods can be marked as static (Shared in Visual Basic).</span></span> <span data-ttu-id="f3334-143">メソッドを静的としてマークすると、コンパイラはこれらのメンバーに対する非仮想呼び出しサイトを出力します。</span><span class="sxs-lookup"><span data-stu-id="f3334-143">After you mark the methods as static, the compiler will emit nonvirtual call sites to these members.</span></span> <span data-ttu-id="f3334-144">パフォーマンス重視のコードでは、これにより大きくパフォーマンスを向上できます。</span><span class="sxs-lookup"><span data-stu-id="f3334-144">This can give you a measurable performance gain for performance-sensitive code.</span></span> |
| [<span data-ttu-id="f3334-145">CA1823:使用されていないプライベート フィールドを使用しません</span><span class="sxs-lookup"><span data-stu-id="f3334-145">CA1823: Avoid unused private fields</span></span>](ca1823.md) | <span data-ttu-id="f3334-146">アセンブリ内でアクセスされていないと思われるプライベート フィールドが検出されました。</span><span class="sxs-lookup"><span data-stu-id="f3334-146">Private fields were detected that do not appear to be accessed in the assembly.</span></span> |
| [<span data-ttu-id="f3334-147">CA1824:アセンブリを NeutralResourcesLanguageAttribute に設定します</span><span class="sxs-lookup"><span data-stu-id="f3334-147">CA1824: Mark assemblies with NeutralResourcesLanguageAttribute</span></span>](ca1824.md) | <span data-ttu-id="f3334-148">NeutralResourcesLanguage 属性は、アセンブリのニュートラルカルチャのリソースを表示するために使用された言語をリソースマネージャーに通知します。</span><span class="sxs-lookup"><span data-stu-id="f3334-148">The NeutralResourcesLanguage attribute informs the Resource Manager of the language that was used to display the resources of a neutral culture for an assembly.</span></span> <span data-ttu-id="f3334-149">これにより、読み込んだ最初のリソースに対する検索のパフォーマンスが向上し、ワーキング セットを縮小できます。</span><span class="sxs-lookup"><span data-stu-id="f3334-149">This improves lookup performance for the first resource that you load and can reduce your working set.</span></span> |
| [<span data-ttu-id="f3334-150">CA1825:長さ 0 の配列割り当てを回避します</span><span class="sxs-lookup"><span data-stu-id="f3334-150">CA1825: Avoid zero-length array allocations</span></span>](ca1825.md) | <span data-ttu-id="f3334-151">長さ0の配列を初期化すると、不要なメモリ割り当てにつながります。</span><span class="sxs-lookup"><span data-stu-id="f3334-151">Initializing a zero-length array leads to unnecessary memory allocation.</span></span> <span data-ttu-id="f3334-152">代わりに、を呼び出すことによって、静的に割り当てられた空の配列インスタンスを使用し <xref:System.Array.Empty%2A?displayProperty=nameWithType> ます。</span><span class="sxs-lookup"><span data-stu-id="f3334-152">Instead, use the statically allocated empty array instance by calling <xref:System.Array.Empty%2A?displayProperty=nameWithType>.</span></span> <span data-ttu-id="f3334-153">メモリ割り当ては、このメソッドのすべての呼び出しで共有されます。</span><span class="sxs-lookup"><span data-stu-id="f3334-153">The memory allocation is shared across all invocations of this method.</span></span> |
| [<span data-ttu-id="f3334-154">CA1826:Linq の列挙可能なメソッドの代わりにプロパティを使用します</span><span class="sxs-lookup"><span data-stu-id="f3334-154">CA1826: Use property instead of Linq Enumerable method</span></span>](ca1826.md) | <span data-ttu-id="f3334-155"><xref:System.Linq.Enumerable> LINQ メソッドが、同等のより効率的なプロパティをサポートする型で使用されました。</span><span class="sxs-lookup"><span data-stu-id="f3334-155"><xref:System.Linq.Enumerable> LINQ method was used on a type that supports an equivalent, more efficient property.</span></span> |
| [<span data-ttu-id="f3334-156">CA1827:Any が使用できる場合は Count/LongCount を使用しません</span><span class="sxs-lookup"><span data-stu-id="f3334-156">CA1827: Do not use Count/LongCount when Any can be used</span></span>](ca1827.md) | <span data-ttu-id="f3334-157"><xref:System.Linq.Enumerable.Count%2A> または <xref:System.Linq.Enumerable.LongCount%2A> メソッドが使用されました <xref:System.Linq.Enumerable.Any%2A> 。メソッドの方が効率的です。</span><span class="sxs-lookup"><span data-stu-id="f3334-157"><xref:System.Linq.Enumerable.Count%2A> or <xref:System.Linq.Enumerable.LongCount%2A> method was used where <xref:System.Linq.Enumerable.Any%2A> method would be more efficient.</span></span> |
| [<span data-ttu-id="f3334-158">CA1828:AnyAsync が使用できる場合は CountAsync/LongCountAsync を使用しません</span><span class="sxs-lookup"><span data-stu-id="f3334-158">CA1828: Do not use CountAsync/LongCountAsync when AnyAsync can be used</span></span>](ca1828.md) | <span data-ttu-id="f3334-159"><xref:Microsoft.EntityFrameworkCore.EntityFrameworkQueryableExtensions.CountAsync%2A> または <xref:Microsoft.EntityFrameworkCore.EntityFrameworkQueryableExtensions.LongCountAsync%2A> メソッドが使用されました <xref:Microsoft.EntityFrameworkCore.EntityFrameworkQueryableExtensions.AnyAsync%2A> 。メソッドの方が効率的です。</span><span class="sxs-lookup"><span data-stu-id="f3334-159"><xref:Microsoft.EntityFrameworkCore.EntityFrameworkQueryableExtensions.CountAsync%2A> or <xref:Microsoft.EntityFrameworkCore.EntityFrameworkQueryableExtensions.LongCountAsync%2A> method was used where <xref:Microsoft.EntityFrameworkCore.EntityFrameworkQueryableExtensions.AnyAsync%2A> method would be more efficient.</span></span> |
| [<span data-ttu-id="f3334-160">CA1829:Enumerable. Count メソッドではなく Length/Count プロパティを使用します</span><span class="sxs-lookup"><span data-stu-id="f3334-160">CA1829: Use Length/Count property instead of Enumerable.Count method</span></span>](ca1829.md) | <span data-ttu-id="f3334-161"><xref:System.Linq.Enumerable.Count%2A> LINQ メソッドは、同等の、より効率的なまたはプロパティをサポートする型で使用されていま `Length` `Count` した。</span><span class="sxs-lookup"><span data-stu-id="f3334-161"><xref:System.Linq.Enumerable.Count%2A> LINQ method was used on a type that supports an equivalent, more efficient `Length` or `Count` property.</span></span> |
| [<span data-ttu-id="f3334-162">CA1830:StringBuilder の厳密に型指定された Append および Insert メソッドのオーバーロードをお勧めします</span><span class="sxs-lookup"><span data-stu-id="f3334-162">CA1830: Prefer strongly-typed Append and Insert method overloads on StringBuilder</span></span>](ca1830.md) | <span data-ttu-id="f3334-163"><xref:System.Text.StringBuilder.Append%2A> と <xref:System.Text.StringBuilder.Insert%2A> は、system.string 以外の複数の型のオーバーロードを提供します。</span><span class="sxs-lookup"><span data-stu-id="f3334-163"><xref:System.Text.StringBuilder.Append%2A> and <xref:System.Text.StringBuilder.Insert%2A> provide overloads for multiple types beyond System.String.</span></span>  <span data-ttu-id="f3334-164">可能であれば、ToString () と文字列ベースのオーバーロードを使用して、厳密に型指定されたオーバーロードを優先します。</span><span class="sxs-lookup"><span data-stu-id="f3334-164">When possible, prefer the strongly-typed overloads over using ToString() and the string-based overload.</span></span> |
| [<span data-ttu-id="f3334-165">CA1831: 該当する場合、文字列に範囲ベースのインデクサーの代わりに AsSpan を使用します</span><span class="sxs-lookup"><span data-stu-id="f3334-165">CA1831: Use AsSpan instead of Range-based indexers for string when appropriate</span></span>](ca1831.md) | <span data-ttu-id="f3334-166">文字列に対して range-インデクサーを使用し、その値を暗黙的に ReadOnlySpan char 型に割り当てると、 &lt; &gt; の代わりにメソッドが <xref:System.String.Substring%2A?#System_String_Substring_System_Int32_System_Int32_> 使用され、 <xref:System.Span%601.Slice%2A?#System_Span_1_Slice_System_Int32_System_Int32_> 文字列の要求された部分のコピーが生成されます。</span><span class="sxs-lookup"><span data-stu-id="f3334-166">When using a range-indexer on a string and implicitly assigning the value to a ReadOnlySpan&lt;char&gt; type, the method <xref:System.String.Substring%2A?#System_String_Substring_System_Int32_System_Int32_> will be used instead of <xref:System.Span%601.Slice%2A?#System_Span_1_Slice_System_Int32_System_Int32_>, which produces a copy of requested portion of the string.</span></span> |
| [<span data-ttu-id="f3334-167">CA1832: 配列の ReadOnlySpan または ReadOnlyMemory 部分を取得するために、範囲ベースのインデクサーの代わりに AsSpan または AsMemory を使用します</span><span class="sxs-lookup"><span data-stu-id="f3334-167">CA1832: Use AsSpan or AsMemory instead of Range-based indexers for getting ReadOnlySpan or ReadOnlyMemory portion of an array</span></span>](ca1832.md) | <span data-ttu-id="f3334-168">配列に対して範囲インデクサーを使用し、その値を型または型に暗黙的に割り当てると、 <xref:System.ReadOnlySpan%601> <xref:System.ReadOnlyMemory%601> の代わりにメソッドが <xref:System.Runtime.CompilerServices.RuntimeHelpers.GetSubArray%2A> 使用され <xref:System.Span%601.Slice%2A?#System_Span_1_Slice_System_Int32_System_Int32_> ます。これにより、配列の要求された部分のコピーが生成されます。</span><span class="sxs-lookup"><span data-stu-id="f3334-168">When using a range-indexer on an array and implicitly assigning the value to a <xref:System.ReadOnlySpan%601> or <xref:System.ReadOnlyMemory%601> type, the method <xref:System.Runtime.CompilerServices.RuntimeHelpers.GetSubArray%2A> will be used instead of <xref:System.Span%601.Slice%2A?#System_Span_1_Slice_System_Int32_System_Int32_>, which produces a copy of requested portion of the array.</span></span> |
| [<span data-ttu-id="f3334-169">CA1833: 配列の Span または Memory 部分を取得するために、範囲ベースのインデクサーの代わりに AsSpan または AsMemory を使用します</span><span class="sxs-lookup"><span data-stu-id="f3334-169">CA1833: Use AsSpan or AsMemory instead of Range-based indexers for getting Span or Memory portion of an array</span></span>](ca1833.md) | <span data-ttu-id="f3334-170">配列に対して範囲インデクサーを使用し、その値を型または型に暗黙的に割り当てると、 <xref:System.Span%601> <xref:System.Memory%601> の代わりにメソッドが <xref:System.Runtime.CompilerServices.RuntimeHelpers.GetSubArray%2A> 使用され <xref:System.Span%601.Slice%2A?#System_Span_1_Slice_System_Int32_System_Int32_> ます。これにより、配列の要求された部分のコピーが生成されます。</span><span class="sxs-lookup"><span data-stu-id="f3334-170">When using a range-indexer on an array and implicitly assigning the value to a <xref:System.Span%601> or <xref:System.Memory%601> type, the method <xref:System.Runtime.CompilerServices.RuntimeHelpers.GetSubArray%2A> will be used instead of <xref:System.Span%601.Slice%2A?#System_Span_1_Slice_System_Int32_System_Int32_>, which produces a copy of requested portion of the array.</span></span> |
| [<span data-ttu-id="f3334-171">CA1834:1 文字の文字列に対して StringBuilder.Append(char) を使用する</span><span class="sxs-lookup"><span data-stu-id="f3334-171">CA1834: Use StringBuilder.Append(char) for single character strings</span></span>](ca1834.md) | <span data-ttu-id="f3334-172"><xref:System.Text.StringBuilder> には `Append` 、引数としてを受け取るオーバーロードがあり `char` ます。</span><span class="sxs-lookup"><span data-stu-id="f3334-172"><xref:System.Text.StringBuilder> has an `Append` overload that takes a `char` as its argument.</span></span> <span data-ttu-id="f3334-173">`char`パフォーマンスを向上させるために、オーバーロードの呼び出しを優先します。</span><span class="sxs-lookup"><span data-stu-id="f3334-173">Prefer calling the `char` overload to improve performance.</span></span> |
| [<span data-ttu-id="f3334-174">CA1835: ' ReadAsync ' と ' WriteAsync ' に対して ' Memory' に基づくオーバーロードを優先します</span><span class="sxs-lookup"><span data-stu-id="f3334-174">CA1835: Prefer the 'Memory'-based overloads for 'ReadAsync' and 'WriteAsync'</span></span>](ca1835.md) | <span data-ttu-id="f3334-175">' Stream ' には、最初の引数として ' Memory byte ' を受け取る ' ReadAsync ' オーバーロード &lt; &gt; と、 &lt; &gt; 1 番目の引数として ' ReadOnlyMemory Byte ' を受け取る ' WriteAsync ' オーバーロードがあります。</span><span class="sxs-lookup"><span data-stu-id="f3334-175">'Stream' has a 'ReadAsync' overload that takes a 'Memory&lt;Byte&gt;' as the first argument, and a 'WriteAsync' overload that takes a 'ReadOnlyMemory&lt;Byte&gt;' as the first argument.</span></span> <span data-ttu-id="f3334-176">より効率的なメモリベースのオーバーロードを呼び出すことをお勧めします。</span><span class="sxs-lookup"><span data-stu-id="f3334-176">Prefer calling the memory based overloads, which are more efficient.</span></span> |
| [<span data-ttu-id="f3334-177">CA1836: `IsEmpty` `Count` 使用可能な場合は優先します。</span><span class="sxs-lookup"><span data-stu-id="f3334-177">CA1836: Prefer `IsEmpty` over `Count` when available</span></span>](ca1836.md) | <span data-ttu-id="f3334-178">`IsEmpty` `Count` `Length` <xref:System.Linq.Enumerable.Count%60%601%28System.Collections.Generic.IEnumerable%7B%60%600%7D%29> <xref:System.Linq.Enumerable.LongCount%60%601%28System.Collections.Generic.IEnumerable%7B%60%600%7D%29> オブジェクトに項目が含まれているかどうかを判断するために、、、またはよりも効率的なプロパティを優先します。</span><span class="sxs-lookup"><span data-stu-id="f3334-178">Prefer `IsEmpty` property that is more efficient than `Count`, `Length`, <xref:System.Linq.Enumerable.Count%60%601%28System.Collections.Generic.IEnumerable%7B%60%600%7D%29> or <xref:System.Linq.Enumerable.LongCount%60%601%28System.Collections.Generic.IEnumerable%7B%60%600%7D%29> to determine whether the object contains or not any items.</span></span> |
| [<span data-ttu-id="f3334-179">CA1837: `Environment.ProcessId` の代わりにを使用します。 `Process.GetCurrentProcess().Id`</span><span class="sxs-lookup"><span data-stu-id="f3334-179">CA1837: Use `Environment.ProcessId` instead of `Process.GetCurrentProcess().Id`</span></span>](ca1837.md) | <span data-ttu-id="f3334-180">`Environment.ProcessId` はより単純で高速です `Process.GetCurrentProcess().Id` 。</span><span class="sxs-lookup"><span data-stu-id="f3334-180">`Environment.ProcessId` is simpler and faster than `Process.GetCurrentProcess().Id`.</span></span> |
| [<span data-ttu-id="f3334-181">CA1838: `StringBuilder` P/invoke のパラメーターを使用しない</span><span class="sxs-lookup"><span data-stu-id="f3334-181">CA1838: Avoid `StringBuilder` parameters for P/Invokes</span></span>](ca1838.md) | <span data-ttu-id="f3334-182">のマーシャリングでは `StringBuilder` 、常にネイティブバッファーコピーが作成されるため、1つのマーシャリング操作に複数の割り当てが行われます。</span><span class="sxs-lookup"><span data-stu-id="f3334-182">Marshaling of `StringBuilder` always creates a native buffer copy, resulting in multiple allocations for one marshaling operation.</span></span> |
