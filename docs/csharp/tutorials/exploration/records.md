---
title: レコード型を使用する - C# チュートリアル
description: レコード型を使用する方法、レコードの階層を構築する方法、クラスではなくレコードを選択する判断基準について説明します。
ms.date: 11/12/2020
ms.openlocfilehash: 8a2cb6966ab4f93432723fd6f82618efa86b26aa
ms.sourcegitcommit: 34968a61e9bac0f6be23ed6ffb837f52d2390c85
ms.translationtype: HT
ms.contentlocale: ja-JP
ms.lasthandoff: 11/17/2020
ms.locfileid: "94688557"
---
# <a name="create-record-types"></a><span data-ttu-id="6fc58-103">レコード型を作成する</span><span class="sxs-lookup"><span data-stu-id="6fc58-103">Create record types</span></span>

<span data-ttu-id="6fc58-104">C# 9 で導入された "*レコード*" は、クラスまたは構造体の代わりに作成できる新しい参照型です。</span><span class="sxs-lookup"><span data-stu-id="6fc58-104">C# 9 introduces *records*, a new reference type that you can create instead of classes or structs.</span></span> <span data-ttu-id="6fc58-105">レコードがクラスと異なるのは、レコード型では "*値ベースの等値性*" が使用されることです。</span><span class="sxs-lookup"><span data-stu-id="6fc58-105">Records are distinct from classes in that record types use *value-based equality*.</span></span> <span data-ttu-id="6fc58-106">レコード型の 2 つの変数は、レコード型の定義が同じで、すべてのフィールドについて、両方のレコードの値が等しい場合、等しいと見なされます。</span><span class="sxs-lookup"><span data-stu-id="6fc58-106">Two variables of a record type are equal if the record type definitions are identical, and if for every field, the values in both records are equal.</span></span> <span data-ttu-id="6fc58-107">クラス型の 2 つの変数は、参照されているオブジェクトが同じクラス型であり、変数で同じオブジェクトが参照されている場合に等しくなります。</span><span class="sxs-lookup"><span data-stu-id="6fc58-107">Two variables of a class type are equal if the objects referred to are the same class type and the variables refer to the same object.</span></span> <span data-ttu-id="6fc58-108">値ベースの等値性により、レコード型では他にもいくつかの機能が必要になると思われます。</span><span class="sxs-lookup"><span data-stu-id="6fc58-108">Value-based equality implies other capabilities you'll probably want in record types.</span></span> <span data-ttu-id="6fc58-109">`class` ではなく `record` を宣言すると、コンパイラによってそれらのメンバーの多くが生成されます。</span><span class="sxs-lookup"><span data-stu-id="6fc58-109">The compiler generates many of those members when you declare a `record` instead of a `class`.</span></span>

<span data-ttu-id="6fc58-110">このチュートリアルで学習する内容は次のとおりです。</span><span class="sxs-lookup"><span data-stu-id="6fc58-110">In this tutorial, you'll learn how to:</span></span>

> [!div class="checklist"]
>
> - <span data-ttu-id="6fc58-111">`class` または `record` を宣言する必要があるかどうかを判断する。</span><span class="sxs-lookup"><span data-stu-id="6fc58-111">Decide if you should declare a `class` or a `record`.</span></span>
> - <span data-ttu-id="6fc58-112">レコード型と位置指定レコード型を宣言する。</span><span class="sxs-lookup"><span data-stu-id="6fc58-112">Declare record types and positional record types.</span></span>
> - <span data-ttu-id="6fc58-113">レコードのコンパイラによって生成されたメソッドを独自のメソッドに置き換える。</span><span class="sxs-lookup"><span data-stu-id="6fc58-113">Substitute your methods for compiler generated methods in records.</span></span>

## <a name="prerequisites"></a><span data-ttu-id="6fc58-114">[前提条件]</span><span class="sxs-lookup"><span data-stu-id="6fc58-114">Prerequisites</span></span>

<span data-ttu-id="6fc58-115">C# 9.0 以降のコンパイラが含まれる .NET 5 以降が実行されるように、コンピューターを設定する必要があります。</span><span class="sxs-lookup"><span data-stu-id="6fc58-115">You’ll need to set up your machine to run .NET 5 or later, including the C# 9.0 or later compiler.</span></span> <span data-ttu-id="6fc58-116">C# 9.0 コンパイラは、[Visual Studio 2019 バージョン 16.8](https://visualstudio.microsoft.com/vs) 以降または [.NET 5.0 SDK](https://dotnet.microsoft.com/download) 以降で使用できます。</span><span class="sxs-lookup"><span data-stu-id="6fc58-116">The C# 9.0 compiler is available starting with [Visual Studio 2019 version 16.8](https://visualstudio.microsoft.com/vs) or the [.NET 5.0 SDK](https://dotnet.microsoft.com/download).</span></span>

## <a name="characteristics-of-records"></a><span data-ttu-id="6fc58-117">レコードの特性</span><span class="sxs-lookup"><span data-stu-id="6fc58-117">Characteristics of records</span></span>

<span data-ttu-id="6fc58-118">"*レコード*" を定義するには、`class` または `struct` キーワードの代わりに、`record` キーワードを使用して型を宣言します。</span><span class="sxs-lookup"><span data-stu-id="6fc58-118">You define a *record* by declaring a type with the `record` keyword, instead of the `class` or `struct` keyword.</span></span> <span data-ttu-id="6fc58-119">レコードは参照型であり、値ベースの等値性のセマンティクスに従います。</span><span class="sxs-lookup"><span data-stu-id="6fc58-119">A record is a reference type and follows value-based equality semantics.</span></span> <span data-ttu-id="6fc58-120">値のセマンティクスを適用するため、コンパイラによりレコード型用のいくつかのメソッドが生成されます。</span><span class="sxs-lookup"><span data-stu-id="6fc58-120">To enforce value semantics, the compiler generates several methods for your record type:</span></span>

- <span data-ttu-id="6fc58-121"><xref:System.Object.Equals(System.Object)?displayProperty=nameWithType> のオーバーライド。</span><span class="sxs-lookup"><span data-stu-id="6fc58-121">An override of <xref:System.Object.Equals(System.Object)?displayProperty=nameWithType>.</span></span>
- <span data-ttu-id="6fc58-122">パラメーターがレコード型である仮想 `Equals` メソッド。</span><span class="sxs-lookup"><span data-stu-id="6fc58-122">A virtual `Equals` method whose parameter is the record type.</span></span>
- <span data-ttu-id="6fc58-123"><xref:System.Object.GetHashCode?displayProperty=nameWithType> のオーバーライド。</span><span class="sxs-lookup"><span data-stu-id="6fc58-123">An override of <xref:System.Object.GetHashCode?displayProperty=nameWithType>.</span></span>
- <span data-ttu-id="6fc58-124">`operator ==` と `operator !=` のメソッド。</span><span class="sxs-lookup"><span data-stu-id="6fc58-124">Methods for `operator ==` and `operator !=`.</span></span>
- <span data-ttu-id="6fc58-125">レコード型によって実装される <xref:System.IEquatable%601?displayProperty=nameWithType>。</span><span class="sxs-lookup"><span data-stu-id="6fc58-125">Record types implement <xref:System.IEquatable%601?displayProperty=nameWithType>.</span></span>

<span data-ttu-id="6fc58-126">さらに、レコードでは <xref:System.Object.ToString?displayProperty=nameWithType> のオーバーライドが提供されます。</span><span class="sxs-lookup"><span data-stu-id="6fc58-126">In addition, records provide an override of <xref:System.Object.ToString?displayProperty=nameWithType>.</span></span> <span data-ttu-id="6fc58-127">コンパイラにより、<xref:System.Object.ToString?displayProperty=nameWithType> を使用してレコードを表示するためのメソッドが合成されます。</span><span class="sxs-lookup"><span data-stu-id="6fc58-127">The compiler synthesizes methods for displaying records using <xref:System.Object.ToString?displayProperty=nameWithType>.</span></span> <span data-ttu-id="6fc58-128">このチュートリアルでコードを記述しながら、それらのメンバーについて調べます。</span><span class="sxs-lookup"><span data-stu-id="6fc58-128">You'll explore those members as you write the code for this tutorial.</span></span> <span data-ttu-id="6fc58-129">レコードでは、レコードの非破壊的な変化を可能にする `with` 式がサポートされています。</span><span class="sxs-lookup"><span data-stu-id="6fc58-129">Records support `with` expressions to enable non-destructive mutation of records.</span></span>

<span data-ttu-id="6fc58-130">また、より簡潔な構文を使用して "*位置指定レコード*" を宣言することもできます。</span><span class="sxs-lookup"><span data-stu-id="6fc58-130">You can also declare *positional records* using a more concise syntax.</span></span> <span data-ttu-id="6fc58-131">位置指定レコードを宣言すると、コンパイラによってさらに多くのメソッドが合成されます。</span><span class="sxs-lookup"><span data-stu-id="6fc58-131">The compiler synthesizes more methods for you when you declare positional records:</span></span>

- <span data-ttu-id="6fc58-132">パラメーターがレコード宣言の位置指定パラメーターと一致するプライマリ コンストラクター。</span><span class="sxs-lookup"><span data-stu-id="6fc58-132">A primary constructor whose parameters match the positional parameters on the record declaration.</span></span>
- <span data-ttu-id="6fc58-133">プライマリ コンストラクターの各パラメーターに対するパブリック初期化専用プロパティ。</span><span class="sxs-lookup"><span data-stu-id="6fc58-133">Public init-only properties for each parameter of a primary constructor.</span></span>
- <span data-ttu-id="6fc58-134">レコードからプロパティを抽出するための `Deconstruct` メソッド。</span><span class="sxs-lookup"><span data-stu-id="6fc58-134">A `Deconstruct` method to extract properties from the record.</span></span>

## <a name="build-temperature-data"></a><span data-ttu-id="6fc58-135">温度データを作成する</span><span class="sxs-lookup"><span data-stu-id="6fc58-135">Build temperature data</span></span>

<span data-ttu-id="6fc58-136">レコードを使用するのが望ましいシナリオには、データと統計に関するものが含まれます。</span><span class="sxs-lookup"><span data-stu-id="6fc58-136">Data and statistics are among the scenarios where you'll want to use records.</span></span> <span data-ttu-id="6fc58-137">このチュートリアルでは、さまざまな用途の "*度日数*" を計算するアプリケーションを作成します。</span><span class="sxs-lookup"><span data-stu-id="6fc58-137">For this tutorial, you'll build an application that computes *degree days* for different uses.</span></span> <span data-ttu-id="6fc58-138">"*度日数*" とは、日、週、または月の単位での熱量 (または熱量不足) の尺度です。</span><span class="sxs-lookup"><span data-stu-id="6fc58-138">*Degree days* are a measure of heat (or lack of heat) over a period of days, weeks, or months.</span></span> <span data-ttu-id="6fc58-139">度日数を使用して、エネルギー使用量を追跡および予測します。</span><span class="sxs-lookup"><span data-stu-id="6fc58-139">Degree days track and predict energy usage.</span></span> <span data-ttu-id="6fc58-140">暑い日が多いほど空調の使用量が増え、寒い日が多いほど暖房の使用量が増えることを意味します。</span><span class="sxs-lookup"><span data-stu-id="6fc58-140">More hotter days means more air conditioning, and more colder days means more furnace usage.</span></span> <span data-ttu-id="6fc58-141">度日数は、植物の生育量を管理するのに役立ちます。</span><span class="sxs-lookup"><span data-stu-id="6fc58-141">Degree days help manage plant populations.</span></span> <span data-ttu-id="6fc58-142">季節の変化のように、度日数と植物の成長の間には相関関係があります。</span><span class="sxs-lookup"><span data-stu-id="6fc58-142">Degree days correlate to plant growth as the seasons change.</span></span> <span data-ttu-id="6fc58-143">度日数は、気候に合わせて場所を変える種の動物の移動を追跡するのに役立ちます。</span><span class="sxs-lookup"><span data-stu-id="6fc58-143">Degree days help track animal migrations for species that travel to match climate.</span></span>

<span data-ttu-id="6fc58-144">数式は、特定の日の平均気温と基準温度に基づいています。</span><span class="sxs-lookup"><span data-stu-id="6fc58-144">The formula is based on the mean temperature on a given day and a baseline temperature.</span></span> <span data-ttu-id="6fc58-145">ある期間の度日数を計算するには、その期間の各日の最高気温と最低気温が必要になります。</span><span class="sxs-lookup"><span data-stu-id="6fc58-145">To compute degree days over time, you'll need the high and low temperature each day for a period of time.</span></span> <span data-ttu-id="6fc58-146">それでは、新しいアプリケーションの作成を始めましょう。</span><span class="sxs-lookup"><span data-stu-id="6fc58-146">Let's start by creating a new application.</span></span> <span data-ttu-id="6fc58-147">新しいコンソール アプリケーションを作成します。</span><span class="sxs-lookup"><span data-stu-id="6fc58-147">Make a new console application.</span></span> <span data-ttu-id="6fc58-148">"DailyTemperature.cs" という名前の新しいファイルに新しいレコード型を作成します。</span><span class="sxs-lookup"><span data-stu-id="6fc58-148">Create a new record type in a new file named "DailyTemperature.cs":</span></span>

:::code language="csharp" source="snippets/record-types/InterimSteps.cs" ID="DailyRecord":::

<span data-ttu-id="6fc58-149">上記のコードでは、"*位置指定レコード*" が定義されています。</span><span class="sxs-lookup"><span data-stu-id="6fc58-149">The preceding code defines a *positional record*.</span></span> <span data-ttu-id="6fc58-150">2 つのプロパティ `HighTemp` と `LowTemp` を含む参照型を作成しました。</span><span class="sxs-lookup"><span data-stu-id="6fc58-150">You've created a reference type that contains two properties: `HighTemp`, and `LowTemp`.</span></span> <span data-ttu-id="6fc58-151">それらのプロパティは "*初期化専用プロパティ*" であり、コンストラクター内で、またはプロパティ初期化子を使用して、設定できることを意味します。</span><span class="sxs-lookup"><span data-stu-id="6fc58-151">Those properties are *init only properties*, meaning they can be set in the constructor or using a property initializer.</span></span> <span data-ttu-id="6fc58-152">`DailyTemperature` 型には、2 つのプロパティと一致する 2 つのパラメーターを持つ "*プライマリ コンストラクター*" もあります。</span><span class="sxs-lookup"><span data-stu-id="6fc58-152">The `DailyTemperature` type also has a *primary constructor* that has two parameters that match the two properties.</span></span> <span data-ttu-id="6fc58-153">`DailyTemperature` レコードを初期化するには、プライマリ コンストラクターを使用します。</span><span class="sxs-lookup"><span data-stu-id="6fc58-153">You use the primary constructor to initialize a `DailyTemperature` record:</span></span>

:::code language="csharp" source="snippets/record-types/Program.cs" ID="DeclareData":::

<span data-ttu-id="6fc58-154">位置指定レコードも含めて、独自のプロパティやメソッドをレコードに追加することができます。</span><span class="sxs-lookup"><span data-stu-id="6fc58-154">You can add your own properties or methods to records, including positional records.</span></span> <span data-ttu-id="6fc58-155">毎日の平均気温を計算する必要があります。</span><span class="sxs-lookup"><span data-stu-id="6fc58-155">You'll need to compute the mean temperature for each day.</span></span> <span data-ttu-id="6fc58-156">そのプロパティを `DailyTemperature` レコードに追加できます。</span><span class="sxs-lookup"><span data-stu-id="6fc58-156">You can add that property to the `DailyTemperature` record:</span></span>

:::code language="csharp" source="snippets/record-types/DailyTemperature.cs" ID="TemperatureRecord":::

<span data-ttu-id="6fc58-157">このデータを使用できることを確認してみましょう。</span><span class="sxs-lookup"><span data-stu-id="6fc58-157">Let's make sure you can use this data.</span></span> <span data-ttu-id="6fc58-158">次のコードを `Main` メソッドに追加します。</span><span class="sxs-lookup"><span data-stu-id="6fc58-158">Add the following code to your `Main` method:</span></span>

```csharp
foreach (var item in data)
    Console.WriteLine(item);
```

<span data-ttu-id="6fc58-159">アプリケーションを実行すると、次のような出力が表示されます (スペースの都合で何行か削除されています)。</span><span class="sxs-lookup"><span data-stu-id="6fc58-159">Run your application, and you'll see output that looks similar to the following display (several rows removed for space):</span></span>

```dotnetcli
DailyTemperature { HighTemp = 57, LowTemp = 30, Mean = 43.5 }
DailyTemperature { HighTemp = 60, LowTemp = 35, Mean = 47.5 }


DailyTemperature { HighTemp = 80, LowTemp = 60, Mean = 70 }
DailyTemperature { HighTemp = 85, LowTemp = 66, Mean = 75.5 }
```

<span data-ttu-id="6fc58-160">上記のコードは、コンパイラによって合成された `ToString` のオーバーライドからの出力を示したものです。</span><span class="sxs-lookup"><span data-stu-id="6fc58-160">The preceding code shows the output from the override of `ToString` synthesized by the compiler.</span></span> <span data-ttu-id="6fc58-161">別のテキストがよい場合は、独自のバージョンの `ToString` を記述できます。</span><span class="sxs-lookup"><span data-stu-id="6fc58-161">If you prefer different text, you can write your own version of `ToString`.</span></span> <span data-ttu-id="6fc58-162">そうすれば、コンパイラによってバージョンが自動的に合成されることはなくなります。</span><span class="sxs-lookup"><span data-stu-id="6fc58-162">That prevents the compiler from synthesizing a version for you.</span></span>

## <a name="compute-degree-days"></a><span data-ttu-id="6fc58-163">度日数を計算する</span><span class="sxs-lookup"><span data-stu-id="6fc58-163">Compute degree days</span></span>

<span data-ttu-id="6fc58-164">度日数を計算するには、基準温度と特定の日の平均気温との差を計算します。</span><span class="sxs-lookup"><span data-stu-id="6fc58-164">To compute degree days, you take the difference from a baseline temperature and the mean temperature on a given day.</span></span> <span data-ttu-id="6fc58-165">ある期間の暑さを測定するには、平均気温が基準値を下回っている日を破棄します。</span><span class="sxs-lookup"><span data-stu-id="6fc58-165">To measure heat over time, you discard any days where the mean temperature is below the baseline.</span></span> <span data-ttu-id="6fc58-166">ある期間の寒さを測定するには、平均気温が基準値を上回っている日を破棄します。</span><span class="sxs-lookup"><span data-stu-id="6fc58-166">To measure cold over time, you discard any days where the mean temperature is above the baseline.</span></span> <span data-ttu-id="6fc58-167">たとえば、米国では、暖房と冷房の両方の度日数に対する基準として 65F が使用されています。</span><span class="sxs-lookup"><span data-stu-id="6fc58-167">For example, the U.S. uses 65F as the base for both heating  and cooling degree days.</span></span> <span data-ttu-id="6fc58-168">これは、暖房や冷房の必要がない温度です。</span><span class="sxs-lookup"><span data-stu-id="6fc58-168">That's the temperature where no heating or cooling is needed.</span></span> <span data-ttu-id="6fc58-169">ある日の平均気温が 70F の場合、その日は 5 冷房度日数で、0 暖房度日数です。</span><span class="sxs-lookup"><span data-stu-id="6fc58-169">If a day has a mean temperature of 70F, that day is 5 cooling degree days and 0 heating degree days.</span></span> <span data-ttu-id="6fc58-170">逆に、平均気温が 55F の場合は、その日は 10 暖房度日数で、0 冷房度日数です。</span><span class="sxs-lookup"><span data-stu-id="6fc58-170">Conversely, if the mean temperature is 55F, that day is 10 heating degree days and 0 cooling degree days.</span></span>

<span data-ttu-id="6fc58-171">これらの数式を、レコード型の小さな階層として表すことができます。つまり、度日を表す 1 つの抽象型と、暖房度日数と冷房度日数のための 2 つの具象型です。</span><span class="sxs-lookup"><span data-stu-id="6fc58-171">You can express these formulas as a small hierarchy of record types: an abstract degree day type and two concrete types for heating degree days and cooling degree days.</span></span> <span data-ttu-id="6fc58-172">これらの型は、位置指定レコードにすることもできます。</span><span class="sxs-lookup"><span data-stu-id="6fc58-172">These types can also be positional records.</span></span> <span data-ttu-id="6fc58-173">それらは、プライマリ コンストラクターの引数として、基準温度と一連の毎日の気温レコードを受け取ります。</span><span class="sxs-lookup"><span data-stu-id="6fc58-173">They take a baseline temperature and a sequence of daily temperature records as arguments to the primary constructor:</span></span>

:::code language="csharp" source="snippets/record-types/InterimSteps.cs" ID="DegreeDaysRecords":::

<span data-ttu-id="6fc58-174">抽象 `DegreeDays` レコードは、`HeatingDegreeDays` レコードと `CoolingDegreeDays` レコードの両方に対する共有基底クラスです。</span><span class="sxs-lookup"><span data-stu-id="6fc58-174">The abstract `DegreeDays` record is the shared base class for both the `HeatingDegreeDays` and `CoolingDegreeDays` records.</span></span> <span data-ttu-id="6fc58-175">派生レコードでのプライマリ コンストラクターの宣言により、基本レコードの初期化を管理する方法が示されています。</span><span class="sxs-lookup"><span data-stu-id="6fc58-175">The primary constructor declarations on the derived records show how to manage base record initialization.</span></span> <span data-ttu-id="6fc58-176">派生レコードにより、基本レコードのプライマリ コンストラクターに含まれるすべてのパラメーターに対するパラメーターが宣言されています。</span><span class="sxs-lookup"><span data-stu-id="6fc58-176">Your derived record declares parameters for all the parameters in the base record primary constructor.</span></span> <span data-ttu-id="6fc58-177">基本レコードにより、それらのプロパティが宣言されて初期化されます。</span><span class="sxs-lookup"><span data-stu-id="6fc58-177">The base record declares and initializes those properties.</span></span> <span data-ttu-id="6fc58-178">派生レコードによってそれらは隠ぺいされませんが、基本レコードで宣言されていないパラメーターのプロパティのみが作成されて初期化されます。</span><span class="sxs-lookup"><span data-stu-id="6fc58-178">The derived record doesn't hide them, but only creates and initializes properties for parameters that aren't declared in its base record.</span></span> <span data-ttu-id="6fc58-179">この例では、派生レコードによって新しいプライマリ コンストラクター パラメーターが追加されることはありません。</span><span class="sxs-lookup"><span data-stu-id="6fc58-179">In this example, the derived records don't add new primary constructor parameters.</span></span> <span data-ttu-id="6fc58-180">`Main` メソッドに次のコードを追加することで、コードをテストします。</span><span class="sxs-lookup"><span data-stu-id="6fc58-180">Test your code by adding the following code to your `Main` method:</span></span>

:::code language="csharp" source="snippets/record-types/Program.cs" ID="HeatingAndCooling":::

<span data-ttu-id="6fc58-181">次のような出力が表示されます。</span><span class="sxs-lookup"><span data-stu-id="6fc58-181">You'll get output like the following display:</span></span>

```dotnetcli
HeatingDegreeDays { BaseTemperature = 65, TempRecords = record_types.DailyTemperature[], DegreeDays = 85 }
CoolingDegreeDays { BaseTemperature = 65, TempRecords = record_types.DailyTemperature[], DegreeDays = 71.5 }
```

## <a name="define-compiler-synthesized-methods"></a><span data-ttu-id="6fc58-182">コンパイラ合成メソッドを定義する</span><span class="sxs-lookup"><span data-stu-id="6fc58-182">Define compiler-synthesized methods</span></span>

<span data-ttu-id="6fc58-183">コードで、その期間における暖房度日数と冷房度日数の正しい値を計算します。</span><span class="sxs-lookup"><span data-stu-id="6fc58-183">Your code calculates the correct number of heating and cooling degree days over that period of time.</span></span> <span data-ttu-id="6fc58-184">ただし、この例では、レコードに対する合成メソッドの一部を置き換える必要がある理由を示します。</span><span class="sxs-lookup"><span data-stu-id="6fc58-184">But this example shows why you may want to replace some of the synthesized methods for records.</span></span> <span data-ttu-id="6fc58-185">クローン メソッドを除き、あるレコード型でのどのコンパイラ合成メソッドについても、独自のバージョンを宣言できます。</span><span class="sxs-lookup"><span data-stu-id="6fc58-185">You can declare your own version of any of the compiler-synthesized methods in a record type except the clone method.</span></span> <span data-ttu-id="6fc58-186">クローン メソッドにはコンパイラによって生成される名前があり、別の実装を提供することはできません。</span><span class="sxs-lookup"><span data-stu-id="6fc58-186">The clone method has a compiler generated name and you cannot provide a different implementation.</span></span> <span data-ttu-id="6fc58-187">これらの合成メソッドには、コピー コンストラクター、<xref:System.IEquatable%601?displayProperty=nameWithType> インターフェイスのメンバー、等値テストと非等値テスト、<xref:System.Object.GetHashCode> が含まれます。</span><span class="sxs-lookup"><span data-stu-id="6fc58-187">These synthesized methods include a copy constructor, the members of the <xref:System.IEquatable%601?displayProperty=nameWithType> interface, equality and inequality tests, and <xref:System.Object.GetHashCode>.</span></span> <span data-ttu-id="6fc58-188">このために、`PrintMembers` を合成します。</span><span class="sxs-lookup"><span data-stu-id="6fc58-188">For this purpose, you'll synthesize `PrintMembers`.</span></span> <span data-ttu-id="6fc58-189">独自の `ToString` を宣言することもできますが、継承のシナリオには`PrintMembers` の方が適しています。</span><span class="sxs-lookup"><span data-stu-id="6fc58-189">You could also declare your own `ToString`, but `PrintMembers` provides a better option for inheritance scenarios.</span></span> <span data-ttu-id="6fc58-190">独自バージョンの合成メソッドを提供するには、シグネチャが合成メソッドと一致している必要があります。</span><span class="sxs-lookup"><span data-stu-id="6fc58-190">To provide your own version of a synthesized method, the signature must match the synthesized method.</span></span>

<span data-ttu-id="6fc58-191">コンソール出力の `TempRecords` 要素は役に立ちません。</span><span class="sxs-lookup"><span data-stu-id="6fc58-191">The `TempRecords` element in the console output isn't useful.</span></span> <span data-ttu-id="6fc58-192">型が表示されるだけで、他には何も表示されません。</span><span class="sxs-lookup"><span data-stu-id="6fc58-192">It displays the type, but nothing else.</span></span> <span data-ttu-id="6fc58-193">合成メソッド `PrintMembers` の独自の実装を提供することにより、この動作を変更できます。</span><span class="sxs-lookup"><span data-stu-id="6fc58-193">You can change this behavior by providing your own implementation of the synthesized `PrintMembers` method.</span></span> <span data-ttu-id="6fc58-194">シグネチャは、`record` の宣言に適用される修飾子によって異なります。</span><span class="sxs-lookup"><span data-stu-id="6fc58-194">The signature depends on modifiers applied to the `record` declaration:</span></span>

- <span data-ttu-id="6fc58-195">レコード型が `sealed` の場合、シグネチャは `private bool PrintMembers(StringBuilder builder);` です</span><span class="sxs-lookup"><span data-stu-id="6fc58-195">If a record type is `sealed`, the signature is `private bool PrintMembers(StringBuilder builder);`</span></span>
- <span data-ttu-id="6fc58-196">レコード型が `sealed` ではなく、`object` から派生している場合は (つまり、基本レコードが宣言されていない場合)、シグネチャは `protected virtual bool PrintMembers(StringBuilder builder);` となります</span><span class="sxs-lookup"><span data-stu-id="6fc58-196">If a record type isn't `sealed` and derives from `object` (that is, it doesn't declare a base record), the signature is `protected virtual bool PrintMembers(StringBuilder builder);`</span></span>
- <span data-ttu-id="6fc58-197">レコード型が `sealed` ではなく、別のレコードから派生している場合は、シグネチャは `protected override bool PrintMembers(StringBuilder builder);` となります</span><span class="sxs-lookup"><span data-stu-id="6fc58-197">If a record type isn't `sealed` and derives from another record, the signature is `protected override bool PrintMembers(StringBuilder builder);`</span></span>

<span data-ttu-id="6fc58-198">これらのルールは、`PrintMembers` の目的を理解することで把握するのが最も簡単です。</span><span class="sxs-lookup"><span data-stu-id="6fc58-198">These rules are easiest to comprehend through understanding the purpose of `PrintMembers`.</span></span> <span data-ttu-id="6fc58-199">`PrintMembers` により、レコード型の各プロパティに関する情報が文字列に追加されます。</span><span class="sxs-lookup"><span data-stu-id="6fc58-199">`PrintMembers` adds information about each property in a record type to a string.</span></span> <span data-ttu-id="6fc58-200">コントラクトでは、表示にメンバーを追加するための基本レコードが必要であり、派生メンバーによってそれらのメンバーが追加されるものと想定されています。</span><span class="sxs-lookup"><span data-stu-id="6fc58-200">The contract requires base records to add their members to the display and assumes derived members will add their members.</span></span> <span data-ttu-id="6fc58-201">各レコード型により、`HeatingDegreeDays` に対する次の例のような `ToString` のオーバーライドが合成されます。</span><span class="sxs-lookup"><span data-stu-id="6fc58-201">Each record type synthesizes a `ToString` override that looks similar to the following example for `HeatingDegreeDays`:</span></span>

```csharp
public override string ToString()
{
    StringBuilder stringBuilder = new StringBuilder();
    stringBuilder.Append("HeatingDegreeDays");
    stringBuilder.Append(" { ");
    if (PrintMembers(stringBuilder))
    {
        stringBuilder.Append(" ");
    }
    stringBuilder.Append("}");
    return stringBuilder.ToString();
}
```

<span data-ttu-id="6fc58-202">コレクションの型が出力されない `DegreeDays` レコードで、`PrintMembers` メソッドを宣言します。</span><span class="sxs-lookup"><span data-stu-id="6fc58-202">You declare a `PrintMembers` method in the `DegreeDays` record that doesn't print the type of the collection:</span></span>

:::code language="csharp" source="snippets/record-types/DegreeDays.cs" ID="AddPrintMembers":::

<span data-ttu-id="6fc58-203">コンパイラのバージョンと一致するように、シグネチャで `virtual protected` メソッドを宣言します。</span><span class="sxs-lookup"><span data-stu-id="6fc58-203">The signature declares a `virtual protected` method to match the compiler's version.</span></span> <span data-ttu-id="6fc58-204">アクセサーが間違っていても気にしないでください。言語によって正しいシグネチャが適用されます。</span><span class="sxs-lookup"><span data-stu-id="6fc58-204">Don't worry if you get the accessors wrong; the language enforces the correct signature.</span></span> <span data-ttu-id="6fc58-205">合成メソッドの正しい修飾子を忘れた場合は、適切なシグネチャを取得するのに役立つ警告またはエラーがコンパイラによって表示されます。</span><span class="sxs-lookup"><span data-stu-id="6fc58-205">If you forget the correct modifiers for any synthesized method, the compiler issues warnings or errors that help you get the right signature.</span></span>

## <a name="non-destructive-mutation"></a><span data-ttu-id="6fc58-206">非破壊的な変化</span><span class="sxs-lookup"><span data-stu-id="6fc58-206">Non-destructive mutation</span></span>

<span data-ttu-id="6fc58-207">位置指定レコードの合成メンバーによって、レコードの状態が変更されることはありません。</span><span class="sxs-lookup"><span data-stu-id="6fc58-207">The synthesized members in a positional record don't modify the state of the record.</span></span> <span data-ttu-id="6fc58-208">目標は、変更不可能なレコードをより簡単に作成できるようにすることです。</span><span class="sxs-lookup"><span data-stu-id="6fc58-208">The goal is that you can more easily create immutable records.</span></span> <span data-ttu-id="6fc58-209">前に示した `HeatingDegreeDays` と `CoolingDegreeDays` の宣言をもう一度見てみましょう。</span><span class="sxs-lookup"><span data-stu-id="6fc58-209">Look again at the preceding declarations for `HeatingDegreeDays` and `CoolingDegreeDays`.</span></span> <span data-ttu-id="6fc58-210">追加されたメンバーにより、レコードの値に対する計算は行われますが、状態は変更されません。</span><span class="sxs-lookup"><span data-stu-id="6fc58-210">The members added perform computations on the values for the record, but don't mutate state.</span></span> <span data-ttu-id="6fc58-211">位置指定レコードを使用すると、変更不可能な参照型をより簡単に作成できます。</span><span class="sxs-lookup"><span data-stu-id="6fc58-211">Positional records make it easier for you to create immutable reference types.</span></span>

<span data-ttu-id="6fc58-212">変更不可能な参照型を作成するということは、非破壊的な変化を使用することを意味します。</span><span class="sxs-lookup"><span data-stu-id="6fc58-212">Creating immutable reference types means you'll want to use non-destructive mutation.</span></span> <span data-ttu-id="6fc58-213">[`with` 式](../../language-reference/operators/with-expression.md)を使用して、既存のレコード インスタンスに似た新しいレコード インスタンスを作成します。</span><span class="sxs-lookup"><span data-stu-id="6fc58-213">You  create new record instances that are similar to existing record instances using [`with` expressions](../../language-reference/operators/with-expression.md).</span></span> <span data-ttu-id="6fc58-214">これらの式は、コピーの構築にコピーを変更する割り当てを追加したものです。</span><span class="sxs-lookup"><span data-stu-id="6fc58-214">These expressions are a copy construction with additional assignments that modify the copy.</span></span> <span data-ttu-id="6fc58-215">結果として、既存のレコードから各プロパティがコピーされ、必要に応じて変更が加えられた、新しいレコード インスタンスが作成されます。</span><span class="sxs-lookup"><span data-stu-id="6fc58-215">The result is a new record instance where each property has been copied from the existing record and optionally modified.</span></span> <span data-ttu-id="6fc58-216">元のレコードは変更されません。</span><span class="sxs-lookup"><span data-stu-id="6fc58-216">The original record is unchanged.</span></span>

<span data-ttu-id="6fc58-217">`with` 式を示すいくつかの機能をプログラムに追加してみましょう。</span><span class="sxs-lookup"><span data-stu-id="6fc58-217">Let's add a couple features to your program that demonstrate `with` expressions.</span></span> <span data-ttu-id="6fc58-218">最初に、同じデータを使用して、成長度日数を計算する新しいレコードを作成してみます。</span><span class="sxs-lookup"><span data-stu-id="6fc58-218">First, let's create a new record to compute growing degree days using the same data.</span></span> <span data-ttu-id="6fc58-219">"*成長度日数*" の場合は、通常、基準として 41F を使用し、基準を上回る温度を測定します。</span><span class="sxs-lookup"><span data-stu-id="6fc58-219">*Growing degree days* typically uses 41F as the baseline and measures temperatures above the baseline.</span></span> <span data-ttu-id="6fc58-220">同じデータを使用するため、`coolingDegreeDays` に似た新しいレコードを作成しますが、異なる基準温度を使用します。</span><span class="sxs-lookup"><span data-stu-id="6fc58-220">To use the same data, you can create a new record that is similar to the `coolingDegreeDays`, but with a different base temperature:</span></span>

:::code language="csharp" source="snippets/record-types/Program.cs" ID="GrowingDegreeDays":::

<span data-ttu-id="6fc58-221">計算された度数と、より高い基準温度で生成された値を比較できます。</span><span class="sxs-lookup"><span data-stu-id="6fc58-221">You can compare the number of degrees computed to the numbers generated with a higher baseline temperature.</span></span> <span data-ttu-id="6fc58-222">レコードは "*参照型*" であり、これらのコピーは簡易コピーであることに注意してください。</span><span class="sxs-lookup"><span data-stu-id="6fc58-222">Remember that records are *reference types* and these copies are shallow copies.</span></span> <span data-ttu-id="6fc58-223">データの配列はコピーされず、両方のレコードで同じデータが参照されています。</span><span class="sxs-lookup"><span data-stu-id="6fc58-223">The array for the data isn't copied, but both records refer to the same data.</span></span> <span data-ttu-id="6fc58-224">その事実は、他のもう 1 つのシナリオでの利点になります。</span><span class="sxs-lookup"><span data-stu-id="6fc58-224">That fact is an advantage in one other scenario.</span></span> <span data-ttu-id="6fc58-225">成長度日数の場合、過去 5 日間の合計を追跡しておくと便利です。</span><span class="sxs-lookup"><span data-stu-id="6fc58-225">For growing degree days, it's useful to keep track of the total for the previous 5 days.</span></span> <span data-ttu-id="6fc58-226">`with` 式を使用して、異なるソース データで新しいレコードを作成できます。</span><span class="sxs-lookup"><span data-stu-id="6fc58-226">You can create new records with different source data using `with` expressions.</span></span> <span data-ttu-id="6fc58-227">次のコードを使用すると、これらの累積のコレクションが作成されてから、値が表示されます。</span><span class="sxs-lookup"><span data-stu-id="6fc58-227">The following code builds a collection of these accumulations, then displays the values:</span></span>

:::code language="csharp" source="snippets/record-types/Program.cs" ID="RunningFiveDayTotal":::

<span data-ttu-id="6fc58-228">`with` 式を使用して、レコードのコピーを作成することもできます。</span><span class="sxs-lookup"><span data-stu-id="6fc58-228">You can also use `with` expressions to create copies of records.</span></span> <span data-ttu-id="6fc58-229">`with` 式の中かっこの間には、プロパティを指定しないでください。</span><span class="sxs-lookup"><span data-stu-id="6fc58-229">Don't specify any properties between the braces for the `with` expression.</span></span> <span data-ttu-id="6fc58-230">それはコピーを作成することを意味し、プロパティは変更されません。</span><span class="sxs-lookup"><span data-stu-id="6fc58-230">That means create a copy, and don't change any properties:</span></span>

```csharp
var growingDegreeDaysCopy = growingDegreeDays with { };
```

<span data-ttu-id="6fc58-231">完成したアプリケーションを実行して結果を確認します。</span><span class="sxs-lookup"><span data-stu-id="6fc58-231">Run the finished application to see the results.</span></span>

## <a name="summary"></a><span data-ttu-id="6fc58-232">まとめ</span><span class="sxs-lookup"><span data-stu-id="6fc58-232">Summary</span></span>

<span data-ttu-id="6fc58-233">このチュートリアルでは、レコードのいくつかの側面を見てきました。</span><span class="sxs-lookup"><span data-stu-id="6fc58-233">This tutorial showed several aspects of records.</span></span> <span data-ttu-id="6fc58-234">レコードにより、基本的な用途がデータの格納である参照型に対する、簡潔な構文が提供されます。</span><span class="sxs-lookup"><span data-stu-id="6fc58-234">Records provide concise syntax for reference types where the fundamental use is storing data.</span></span> <span data-ttu-id="6fc58-235">オブジェクト指向のクラスの場合は、基本的な用途は役割を定義することです。</span><span class="sxs-lookup"><span data-stu-id="6fc58-235">For object-oriented classes, the fundamental use is defining responsibilities.</span></span> <span data-ttu-id="6fc58-236">このチュートリアルで焦点を当てた "*位置指定レコード*" を使用すると、簡潔な構文を使用して、レコードの初期化専用プロパティを宣言できます。</span><span class="sxs-lookup"><span data-stu-id="6fc58-236">This tutorial focused on *positional records*, where you can use a concise syntax to declare the init-only properties for a record.</span></span> <span data-ttu-id="6fc58-237">コンパイラにより、レコードのコピーと比較のために、レコードの複数のメンバーが合成されます。</span><span class="sxs-lookup"><span data-stu-id="6fc58-237">The compiler synthesizes several members of the record for copying and comparing records.</span></span> <span data-ttu-id="6fc58-238">レコード型の必要に応じて他のメンバーを追加できます。</span><span class="sxs-lookup"><span data-stu-id="6fc58-238">You can add any other members you need for your record types.</span></span> <span data-ttu-id="6fc58-239">コンパイラによって生成されるどのメンバーも状態が変化しないことがわかっている場合は、変更不可能なレコード型を作成できます。</span><span class="sxs-lookup"><span data-stu-id="6fc58-239">You can create immutable record types knowing that none of the compiler-generated members would mutate state.</span></span> <span data-ttu-id="6fc58-240">位置指定レコードの場合は、`with` 式を使用すると、非破壊的な変化のサポートが容易になります。</span><span class="sxs-lookup"><span data-stu-id="6fc58-240">For positional records, `with` expressions make it easy to support non-destructive mutation.</span></span>

<span data-ttu-id="6fc58-241">レコードにより、型を定義する別の方法が追加されます。</span><span class="sxs-lookup"><span data-stu-id="6fc58-241">Records add another way to define types.</span></span> <span data-ttu-id="6fc58-242">オブジェクトの役割と動作に焦点を当てたオブジェクト指向の階層を作成するには、`class` 定義を使用します。</span><span class="sxs-lookup"><span data-stu-id="6fc58-242">You use `class` definitions to create object-oriented hierarchies that focus on the responsibilities and behavior of objects.</span></span> <span data-ttu-id="6fc58-243">データを格納する、効率的にコピーするのに十分に小さいデータ構造の場合は、`struct` 型を作成します。</span><span class="sxs-lookup"><span data-stu-id="6fc58-243">You create `struct` types for data structures that store data and are small enough to copy efficiently.</span></span> <span data-ttu-id="6fc58-244">値ベースの等値性と比較が必要で、値をコピーする必要はなく、参照変数を使用したい場合は、レコードを作成します。</span><span class="sxs-lookup"><span data-stu-id="6fc58-244">You create records when you want value-based equality and comparison, don't want to copy values, and want to use reference variables.</span></span>

<span data-ttu-id="6fc58-245">レコードの詳細な説明については、[提案されているレコード型の仕様](~/_csharplang/proposals/csharp-9.0/records.md)に関するページを参照してください。</span><span class="sxs-lookup"><span data-stu-id="6fc58-245">You can learn the complete description of records by reading the [proposed record type specification](~/_csharplang/proposals/csharp-9.0/records.md).</span></span>
