---
title: F# スタイル ガイド
description: 優れた F# コードの 5 つの原則について説明します。
ms.date: 12/10/2018
ms.openlocfilehash: 9f47257626e04b09b546de2ae315d48d791678be
ms.sourcegitcommit: 67ebdb695fd017d79d9f1f7f35d145042d5a37f7
ms.translationtype: HT
ms.contentlocale: ja-JP
ms.lasthandoff: 10/20/2020
ms.locfileid: "92223650"
---
# <a name="f-style-guide"></a><span data-ttu-id="fbe23-103">F# スタイル ガイド</span><span class="sxs-lookup"><span data-stu-id="fbe23-103">F# style guide</span></span>

<span data-ttu-id="fbe23-104">次の記事では、F# コードを書式設定するためのガイドラインと、言語の機能の時事的なガイドとその使用方法について説明します。</span><span class="sxs-lookup"><span data-stu-id="fbe23-104">The following articles describe guidelines for formatting F# code and topical guidance for features of the language and how they should be used.</span></span>

<span data-ttu-id="fbe23-105">このガイドは、さまざまなプログラマのグループで使用されている F# の大規模なコードベースでの使用に基づいて作成されています。</span><span class="sxs-lookup"><span data-stu-id="fbe23-105">This guidance has been formulated based on the use of F# in large codebases with a diverse group of programmers.</span></span> <span data-ttu-id="fbe23-106">このガイドにより、一般的に F# を正しく使用できるようになり、時間の経過に伴ってプログラムに対する要件が変化した場合の不満を最小限に抑えることができます。</span><span class="sxs-lookup"><span data-stu-id="fbe23-106">This guidance generally leads to successful use of F# and minimizes frustrations when requirements for programs change over time.</span></span>

## <a name="five-principles-of-good-f-code"></a><span data-ttu-id="fbe23-107">優れた F# コードの 5 つの原則</span><span class="sxs-lookup"><span data-stu-id="fbe23-107">Five principles of good F# code</span></span>

<span data-ttu-id="fbe23-108">F# コードを記述する場合、特に時間の経過と共に変化するシステムでは、常に次の原則に留意する必要があります。</span><span class="sxs-lookup"><span data-stu-id="fbe23-108">Keep the following principles in mind any time you write F# code, especially in systems that will change over time.</span></span> <span data-ttu-id="fbe23-109">以降の記事に記載されているそれぞれの全説明は、次の 5 つの点を基にしています。</span><span class="sxs-lookup"><span data-stu-id="fbe23-109">Every piece of guidance in further articles stems from these five points.</span></span>

1. <span data-ttu-id="fbe23-110">**優れた F# コードは、簡潔で、わかりやすく、組み立てることが容易である**</span><span class="sxs-lookup"><span data-stu-id="fbe23-110">**Good F# code is succinct, expressive, and composable**</span></span>

    <span data-ttu-id="fbe23-111">F# には、少ないコード行でアクションを表現したり、一般的な機能を再利用したりするための機能が多数あります。</span><span class="sxs-lookup"><span data-stu-id="fbe23-111">F# has many features that allow you to express actions in fewer lines of code and reuse generic functionality.</span></span> <span data-ttu-id="fbe23-112">F# のコア ライブラリには、一般的なデータ コレクションを操作するのに便利な型および関数も多数含まれています。</span><span class="sxs-lookup"><span data-stu-id="fbe23-112">The F# core library also contains many useful types and functions for working with common collections of data.</span></span> <span data-ttu-id="fbe23-113">F# でプログラミングする場合の決まりきった慣用的な手順の 1 つには、自分独自の関数と、F# コア ライブラリ (またはその他のライブラリ) の関数の構成があります。</span><span class="sxs-lookup"><span data-stu-id="fbe23-113">Composition of your own functions and those in the F# core library (or other libraries) is a part of routine idiomatic F# programming.</span></span> <span data-ttu-id="fbe23-114">一般に、ある問題に対する解決策を少ないコード行で表現した場合、他の開発者 (または将来の自分) にとってメリットになります。</span><span class="sxs-lookup"><span data-stu-id="fbe23-114">As a general rule, if you can express a solution to a problem in fewer lines of code, other developers (or your future self) will be appreciative.</span></span> <span data-ttu-id="fbe23-115">重要なタスクを実行する場合、FSharp.Core などのライブラリ、F# が実行される[膨大な量の .NET のライブラリ](../../../api/index.md)、または [NuGet](https://www.nuget.org/) のサードパーティ製のパッケージを使用することも強く推奨されます。</span><span class="sxs-lookup"><span data-stu-id="fbe23-115">It's also highly recommended that you use a library such as FSharp.Core, the [vast .NET libraries](../../../api/index.md) that F# runs on, or a third-party package on [NuGet](https://www.nuget.org/) when you need to do a nontrivial task.</span></span>

2. <span data-ttu-id="fbe23-116">**優れた F# コードは相互運用できる**</span><span class="sxs-lookup"><span data-stu-id="fbe23-116">**Good F# code is interoperable**</span></span>

    <span data-ttu-id="fbe23-117">さまざまな言語でコードを使用できるようにするなど、相互運用にはさまざまな形態があります。</span><span class="sxs-lookup"><span data-stu-id="fbe23-117">Interoperation can take multiple forms, including consuming code in different languages.</span></span> <span data-ttu-id="fbe23-118">他の呼び出し元によって相互運用されるあなたのコードの境界は、その呼び出し元でも F# が使用されている場合でも、必ず正確である必要がある重要な部分です。</span><span class="sxs-lookup"><span data-stu-id="fbe23-118">The boundaries of your code that other callers interoperate with are critical pieces to get right, even if the callers are also in F#.</span></span> <span data-ttu-id="fbe23-119">F# でコードを記述する場合、C# コードなどの別の言語で行う場合も含め、あなたが記述するコードが他のコードからどのように呼び出されるかを常に考える必要があります。</span><span class="sxs-lookup"><span data-stu-id="fbe23-119">When writing F#, you should always be thinking about how other code will call into the code you're writing, including if they do so from another language like C#.</span></span> <span data-ttu-id="fbe23-120">相互運用性の詳細については、「[F# コンポーネント デザインのガイドライン](component-design-guidelines.md)」で説明しています。</span><span class="sxs-lookup"><span data-stu-id="fbe23-120">The [F# Component Design Guidelines](component-design-guidelines.md) describe interoperability in detail.</span></span>

3. <span data-ttu-id="fbe23-121">**優れた F# コードはオブジェクト指向ではなく、オブジェクト プログラミングを活用している**</span><span class="sxs-lookup"><span data-stu-id="fbe23-121">**Good F# code makes use of object programming, not object orientation**</span></span>

    <span data-ttu-id="fbe23-122">F# でのプログラミングでは、[クラス](../language-reference/classes.md)、[インターフェイス](../language-reference/interfaces.md)、[アクセス修飾子](../language-reference/access-control.md)、[抽象クラス](../language-reference/abstract-classes.md)など、.NET のすべてのオブジェクトがサポートされています。</span><span class="sxs-lookup"><span data-stu-id="fbe23-122">F# has full support for programming with objects in .NET, including [classes](../language-reference/classes.md), [interfaces](../language-reference/interfaces.md), [access modifiers](../language-reference/access-control.md), [abstract classes](../language-reference/abstract-classes.md), and so on.</span></span> <span data-ttu-id="fbe23-123">コンテキスト対応にする必要がある関数など、より複雑な関数型のコードの場合、オブジェクトでは、関数ではできない方法で簡単にコンテキスト情報をカプセル化できます。</span><span class="sxs-lookup"><span data-stu-id="fbe23-123">For more complicated functional code, such as functions that must be context-aware, objects can easily encapsulate contextual information in ways that functions cannot.</span></span> <span data-ttu-id="fbe23-124">[省略可能なパラメーター](../language-reference/members/methods.md#optional-arguments)などの機能および[オーバーロード](../language-reference/members/methods.md#overloaded-methods)を慎重に使用することにより、この機能を呼び出し元で簡単に利用できます。</span><span class="sxs-lookup"><span data-stu-id="fbe23-124">Features such as [optional parameters](../language-reference/members/methods.md#optional-arguments) and careful use of [overloading](../language-reference/members/methods.md#overloaded-methods) can make consumption of this functionality easier for callers.</span></span>

4. <span data-ttu-id="fbe23-125">**優れた F# コードは変更を公開しないでうまく動作する**</span><span class="sxs-lookup"><span data-stu-id="fbe23-125">**Good F# code performs well without exposing mutation**</span></span>

    <span data-ttu-id="fbe23-126">パフォーマンスの高いコードの記述に変更の使用が不可欠であるということは、周知の事実です。</span><span class="sxs-lookup"><span data-stu-id="fbe23-126">It's no secret that to write high-performance code, you must use mutation.</span></span> <span data-ttu-id="fbe23-127">結局のところ、それがコンピューターが動作するしくみです。</span><span class="sxs-lookup"><span data-stu-id="fbe23-127">It's how computers work, after all.</span></span> <span data-ttu-id="fbe23-128">このようなコードは多くの場合、エラーを起こしやすく、正すのは困難です。</span><span class="sxs-lookup"><span data-stu-id="fbe23-128">Such code is often error-prone and difficult to get right.</span></span> <span data-ttu-id="fbe23-129">呼び出し元には変更は公開しないようにしてください。</span><span class="sxs-lookup"><span data-stu-id="fbe23-129">Avoid exposing mutation to callers.</span></span> <span data-ttu-id="fbe23-130">パフォーマンスが重要な場合には、代わりに[変更ベースの実装を表示しない機能インターフェイス](conventions.md#performance)を構築してください。</span><span class="sxs-lookup"><span data-stu-id="fbe23-130">Instead, [build a functional interface that hides a mutation-based implementation](conventions.md#performance) when performance is critical.</span></span>

5. <span data-ttu-id="fbe23-131">**優れた F# コードはツールで使用できる**</span><span class="sxs-lookup"><span data-stu-id="fbe23-131">**Good F# code is toolable**</span></span>

    <span data-ttu-id="fbe23-132">ツールは、大規模なコードベースで作業するうえで計り知れない価値があるため、F# コードは、F# 言語のツールでより効果的に使用できるよう記述します。</span><span class="sxs-lookup"><span data-stu-id="fbe23-132">Tools are invaluable for working in large codebases, and you can write F# code such that it can be used more effectively with F# language tooling.</span></span> <span data-ttu-id="fbe23-133">一例として、デバッガーで中間値を調べることができるように、ポイントフリー スタイルを使用してプログラミングし過ぎないようにすることがあります。</span><span class="sxs-lookup"><span data-stu-id="fbe23-133">One example is making sure you don't overdo it with a point-free style of programming, so that intermediate values can be inspected with a debugger.</span></span> <span data-ttu-id="fbe23-134">別の例には、コンストラクトを説明する [XML ドキュメントのコメント](../language-reference/xml-documentation.md)を使用して、呼び出しサイトのエディターのツールヒントでそれらのコメントを表示できるようにすることがあります。</span><span class="sxs-lookup"><span data-stu-id="fbe23-134">Another example is using [XML documentation comments](../language-reference/xml-documentation.md) describing constructs such that tooltips in editors can display those comments at the call site.</span></span> <span data-ttu-id="fbe23-135">他のプログラマが使用するツールで、自分のコードがどのように読み取られ、ナビゲーションされ、デバッグされ、操作されるかを常に考慮してください。</span><span class="sxs-lookup"><span data-stu-id="fbe23-135">Always think about how your code will be read, navigated, debugged, and manipulated by other programmers with their tools.</span></span>

## <a name="next-steps"></a><span data-ttu-id="fbe23-136">次のステップ</span><span class="sxs-lookup"><span data-stu-id="fbe23-136">Next steps</span></span>

<span data-ttu-id="fbe23-137">「[F# コードのフォーマットに関するガイドライン](formatting.md)」では、コードを読みやすく書式設定する方法について説明しています。</span><span class="sxs-lookup"><span data-stu-id="fbe23-137">The [F# code formatting guidelines](formatting.md) provide guidance on how to format code so that it is easy to read.</span></span>

<span data-ttu-id="fbe23-138">「[F# のコーディング規則](conventions.md)」では、F# の大規模なコードベースを長期保守する場合に助けとなる F# でのプログラミングのイディオムについて説明しています。</span><span class="sxs-lookup"><span data-stu-id="fbe23-138">The [F# coding conventions](conventions.md) provide guidance for F# programming idioms that will help the long-term maintenance of larger F# codebases.</span></span>

<span data-ttu-id="fbe23-139">「[F# コンポーネント デザインのガイドライン](component-design-guidelines.md)」では、ライブラリなどの F# コンポーネントの作成について説明しています。</span><span class="sxs-lookup"><span data-stu-id="fbe23-139">The [F# component design guidelines](component-design-guidelines.md) provide guidance for authoring F# components, such as libraries.</span></span>
