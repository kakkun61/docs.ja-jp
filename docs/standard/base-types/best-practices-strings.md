---
title: .NET での文字列の比較に関するベスト プラクティス
description: .NET アプリケーションで文字列を効果的に比較する方法について説明します。
ms.date: 05/01/2019
ms.technology: dotnet-standard
dev_langs:
- csharp
- vb
helpviewer_keywords:
- strings [.NET],searching
- best practices,string comparison and sorting
- strings [.NET],best practices
- strings [.NET],basic string operations
- sorting strings
- strings [.NET],sorting
- string comparison [.NET],best practices
- string sorting
- comparing strings
- strings [.NET],comparing
ms.assetid: b9f0bf53-e2de-4116-8ce9-d4f91a1df4f7
ms.openlocfilehash: 167b9b865fb0f674559e2b87db3ed4d6d5048ffe
ms.sourcegitcommit: 48466b8fb7332ececff5dc388f19f6b3ff503dd4
ms.translationtype: HT
ms.contentlocale: ja-JP
ms.lasthandoff: 11/05/2020
ms.locfileid: "93400827"
---
# <a name="best-practices-for-comparing-strings-in-net"></a><span data-ttu-id="18c37-103">.NET での文字列の比較に関するベスト プラクティス</span><span class="sxs-lookup"><span data-stu-id="18c37-103">Best practices for comparing strings in .NET</span></span>

<span data-ttu-id="18c37-104">.NET には、ローカライズされたアプリケーションやグローバル化されたアプリケーションを開発するための広範なサポートが用意されており、文字列の並べ替えや表示などの一般的な操作を実行するときに、現在のカルチャの規則や特定のカルチャの規則を簡単に適用できるようになっています。</span><span class="sxs-lookup"><span data-stu-id="18c37-104">.NET provides extensive support for developing localized and globalized applications, and makes it easy to apply the conventions of either the current culture or a specific culture when performing common operations such as sorting and displaying strings.</span></span> <span data-ttu-id="18c37-105">しかし、文字列の並べ替えや比較の操作は、必ずしもカルチャに依存するとは限りません。</span><span class="sxs-lookup"><span data-stu-id="18c37-105">But sorting or comparing strings is not always a culture-sensitive operation.</span></span> <span data-ttu-id="18c37-106">たとえば、アプリケーションが内部で使用する文字列は、通常、すべてのカルチャで同じように処理される必要があります。</span><span class="sxs-lookup"><span data-stu-id="18c37-106">For example, strings that are used internally by an application typically should be handled identically across all cultures.</span></span> <span data-ttu-id="18c37-107">XML タグ、HTML タグ、ユーザー名、ファイル パス、システム オブジェクトの名前などのカルチャに依存しない文字列データがカルチャに依存するかのように解釈されると、アプリケーション コードで軽度のバグが発生したり、パフォーマンスが低下したり、場合によってはセキュリティの問題を引き起こしたりする可能性があります。</span><span class="sxs-lookup"><span data-stu-id="18c37-107">When culturally independent string data, such as XML tags, HTML tags, user names, file paths, and the names of system objects, are interpreted as if they were culture-sensitive, application code can be subject to subtle bugs, poor performance, and, in some cases, security issues.</span></span>

<span data-ttu-id="18c37-108">ここでは、.NET の文字列の並べ替え、比較、および大文字と小文字の区別のメソッドについて検討し、適切な文字列処理メソッドを選択するための推奨事項と、文字列処理メソッドに関する追加情報を紹介します。</span><span class="sxs-lookup"><span data-stu-id="18c37-108">This article examines the string sorting, comparison, and casing methods in .NET, presents recommendations for selecting an appropriate string-handling method, and provides additional information about string-handling methods.</span></span>

## <a name="recommendations-for-string-usage"></a><span data-ttu-id="18c37-109">文字列の使用に関する推奨事項</span><span class="sxs-lookup"><span data-stu-id="18c37-109">Recommendations for string usage</span></span>

<span data-ttu-id="18c37-110">.NET による開発で文字列を比較するときは、以下の簡単な推奨事項に従ってください。</span><span class="sxs-lookup"><span data-stu-id="18c37-110">When you develop with .NET, follow these simple recommendations when you compare strings:</span></span>

- <span data-ttu-id="18c37-111">文字列操作に対して文字列比較の規則を明示的に指定するオーバーロードを使用します。</span><span class="sxs-lookup"><span data-stu-id="18c37-111">Use overloads that explicitly specify the string comparison rules for string operations.</span></span> <span data-ttu-id="18c37-112">そのためには、通常、<xref:System.StringComparison> 型のパラメーターを持つメソッド オーバーロードを呼び出します。</span><span class="sxs-lookup"><span data-stu-id="18c37-112">Typically, this involves calling a method overload that has a parameter of type <xref:System.StringComparison>.</span></span>
- <span data-ttu-id="18c37-113">カルチャに依存しない文字列照合の安全な既定の方法として、<xref:System.StringComparison.Ordinal?displayProperty=nameWithType> または <xref:System.StringComparison.OrdinalIgnoreCase?displayProperty=nameWithType> を使用して比較を行います。</span><span class="sxs-lookup"><span data-stu-id="18c37-113">Use <xref:System.StringComparison.Ordinal?displayProperty=nameWithType> or <xref:System.StringComparison.OrdinalIgnoreCase?displayProperty=nameWithType> for comparisons as your safe default for culture-agnostic string matching.</span></span>
- <span data-ttu-id="18c37-114">パフォーマンスを向上させるには、<xref:System.StringComparison.Ordinal?displayProperty=nameWithType> または <xref:System.StringComparison.OrdinalIgnoreCase?displayProperty=nameWithType> による比較を使用します。</span><span class="sxs-lookup"><span data-stu-id="18c37-114">Use comparisons with <xref:System.StringComparison.Ordinal?displayProperty=nameWithType> or <xref:System.StringComparison.OrdinalIgnoreCase?displayProperty=nameWithType> for better performance.</span></span>
- <span data-ttu-id="18c37-115">ユーザーに出力を表示する場合は、<xref:System.StringComparison.CurrentCulture?displayProperty=nameWithType> に基づく文字列操作を使用します。</span><span class="sxs-lookup"><span data-stu-id="18c37-115">Use string operations that are based on <xref:System.StringComparison.CurrentCulture?displayProperty=nameWithType> when you display output to the user.</span></span>
- <span data-ttu-id="18c37-116">比較が言語的な意味を持たない場合 (記号としての比較など) は、<xref:System.Globalization.CultureInfo.InvariantCulture%2A?displayProperty=nameWithType> に基づく文字列操作ではなく、非言語的な <xref:System.StringComparison.Ordinal?displayProperty=nameWithType> 値または <xref:System.StringComparison.OrdinalIgnoreCase?displayProperty=nameWithType> 値を使用します。</span><span class="sxs-lookup"><span data-stu-id="18c37-116">Use the non-linguistic <xref:System.StringComparison.Ordinal?displayProperty=nameWithType> or <xref:System.StringComparison.OrdinalIgnoreCase?displayProperty=nameWithType> values instead of string operations based on <xref:System.Globalization.CultureInfo.InvariantCulture%2A?displayProperty=nameWithType> when the comparison is linguistically irrelevant (symbolic, for example).</span></span>
- <span data-ttu-id="18c37-117">比較のために文字列を正規化する場合は <xref:System.String.ToLowerInvariant%2A?displayProperty=nameWithType> メソッドではなく、<xref:System.String.ToUpperInvariant%2A?displayProperty=nameWithType> メソッドを使用します。</span><span class="sxs-lookup"><span data-stu-id="18c37-117">Use the <xref:System.String.ToUpperInvariant%2A?displayProperty=nameWithType> method instead of the <xref:System.String.ToLowerInvariant%2A?displayProperty=nameWithType> method when you normalize strings for comparison.</span></span>
- <span data-ttu-id="18c37-118">2 つの文字列が等価かどうかをテストするには、<xref:System.String.Equals%2A?displayProperty=nameWithType> メソッドのオーバーロードを使用します。</span><span class="sxs-lookup"><span data-stu-id="18c37-118">Use an overload of the <xref:System.String.Equals%2A?displayProperty=nameWithType> method to test whether two strings are equal.</span></span>
- <span data-ttu-id="18c37-119"><xref:System.String.Compare%2A?displayProperty=nameWithType> メソッドと <xref:System.String.CompareTo%2A?displayProperty=nameWithType> メソッドは、文字列を並べ替える場合に使用し、文字列の等価性を確認する場合には使用しません。</span><span class="sxs-lookup"><span data-stu-id="18c37-119">Use the <xref:System.String.Compare%2A?displayProperty=nameWithType> and <xref:System.String.CompareTo%2A?displayProperty=nameWithType> methods to sort strings, not to check for equality.</span></span>
- <span data-ttu-id="18c37-120">数値、日付など、文字列以外のデータをユーザー インターフェイスに表示するには、カルチャに依存する書式設定を使用します。</span><span class="sxs-lookup"><span data-stu-id="18c37-120">Use culture-sensitive formatting to display non-string data, such as numbers and dates, in a user interface.</span></span> <span data-ttu-id="18c37-121">文字列以外のデータを文字列形式で保持するには、[インバリアント カルチャ](xref:System.Globalization.CultureInfo.InvariantCulture)を使用する書式設定を使用します。</span><span class="sxs-lookup"><span data-stu-id="18c37-121">Use formatting with the [invariant culture](xref:System.Globalization.CultureInfo.InvariantCulture) to persist non-string data in string form.</span></span>

<span data-ttu-id="18c37-122">文字列を比較するときに避ける必要があることを次に示します。</span><span class="sxs-lookup"><span data-stu-id="18c37-122">Avoid the following practices when you compare strings:</span></span>

- <span data-ttu-id="18c37-123">文字列操作に対して文字列比較の規則を明示的または暗黙的に指定しないオーバーロードは使用しないでください。</span><span class="sxs-lookup"><span data-stu-id="18c37-123">Do not use overloads that do not explicitly or implicitly specify the string comparison rules for string operations.</span></span>
- <span data-ttu-id="18c37-124">ほとんどの場合、<xref:System.StringComparison.InvariantCulture?displayProperty=nameWithType> に基づく文字列操作は使用しないでください。</span><span class="sxs-lookup"><span data-stu-id="18c37-124">Do not use string operations based on <xref:System.StringComparison.InvariantCulture?displayProperty=nameWithType> in most cases.</span></span> <span data-ttu-id="18c37-125">数少ない例外の 1 つは、言語的な意味を持つがカルチャには依存しないデータを永続化する場合です。</span><span class="sxs-lookup"><span data-stu-id="18c37-125">One of the few exceptions is when you are persisting linguistically meaningful but culturally agnostic data.</span></span>
- <span data-ttu-id="18c37-126">2 つの文字列が等価かどうかを確認する場合に、<xref:System.String.Compare%2A?displayProperty=nameWithType> メソッドまたは <xref:System.String.CompareTo%2A> メソッドのオーバーロードで戻り値が 0 かどうかをテストする方法は使用しないでください。</span><span class="sxs-lookup"><span data-stu-id="18c37-126">Do not use an overload of the <xref:System.String.Compare%2A?displayProperty=nameWithType> or <xref:System.String.CompareTo%2A> method and test for a return value of zero to determine whether two strings are equal.</span></span>

## <a name="specifying-string-comparisons-explicitly"></a><span data-ttu-id="18c37-127">文字列比較の明示的な指定</span><span class="sxs-lookup"><span data-stu-id="18c37-127">Specifying string comparisons explicitly</span></span>

<span data-ttu-id="18c37-128">.NET の文字列操作メソッドは、ほとんどがオーバーロードされています。</span><span class="sxs-lookup"><span data-stu-id="18c37-128">Most of the string manipulation methods in .NET are overloaded.</span></span> <span data-ttu-id="18c37-129">通常は、既定の設定をそのまま使用する 1 つまたは複数のオーバーロードと、既定の設定を使用せずに文字列の比較または操作の正確な方法を定義するその他のオーバーロードがあります。</span><span class="sxs-lookup"><span data-stu-id="18c37-129">Typically, one or more overloads accept default settings, whereas others accept no defaults and instead define the precise way in which strings are to be compared or manipulated.</span></span> <span data-ttu-id="18c37-130">既定の設定に依存しないメソッドには、ほとんどの場合、 <xref:System.StringComparison>型のパラメーターが含まれています。これは、カルチャおよび大文字と小文字の区別によって文字列比較の規則を明示的に指定する列挙型です。</span><span class="sxs-lookup"><span data-stu-id="18c37-130">Most of the methods that do not rely on defaults include a parameter of type <xref:System.StringComparison>, which is an enumeration that explicitly specifies rules for string comparison by culture and case.</span></span> <span data-ttu-id="18c37-131"><xref:System.StringComparison> 列挙型のメンバーを次の表に示します。</span><span class="sxs-lookup"><span data-stu-id="18c37-131">The following table describes the <xref:System.StringComparison> enumeration members.</span></span>

|<span data-ttu-id="18c37-132">StringComparison のメンバー</span><span class="sxs-lookup"><span data-stu-id="18c37-132">StringComparison member</span></span>|<span data-ttu-id="18c37-133">説明</span><span class="sxs-lookup"><span data-stu-id="18c37-133">Description</span></span>|
|-----------------------------|-----------------|
|<xref:System.StringComparison.CurrentCulture>|<span data-ttu-id="18c37-134">現在のカルチャを使用して、大文字と小文字を区別する比較を実行します。</span><span class="sxs-lookup"><span data-stu-id="18c37-134">Performs a case-sensitive comparison using the current culture.</span></span>|
|<xref:System.StringComparison.CurrentCultureIgnoreCase>|<span data-ttu-id="18c37-135">現在のカルチャを使用して、大文字と小文字を区別しない比較を実行します。</span><span class="sxs-lookup"><span data-stu-id="18c37-135">Performs a case-insensitive comparison using the current culture.</span></span>|
|<xref:System.StringComparison.InvariantCulture>|<span data-ttu-id="18c37-136">インバリアント カルチャを使用して、大文字と小文字を区別する比較を実行します。</span><span class="sxs-lookup"><span data-stu-id="18c37-136">Performs a case-sensitive comparison using the invariant culture.</span></span>|
|<xref:System.StringComparison.InvariantCultureIgnoreCase>|<span data-ttu-id="18c37-137">インバリアント カルチャを使用して、大文字と小文字を区別しない比較を実行します。</span><span class="sxs-lookup"><span data-stu-id="18c37-137">Performs a case-insensitive comparison using the invariant culture.</span></span>|
|<xref:System.StringComparison.Ordinal>|<span data-ttu-id="18c37-138">序数に基づく比較を実行します。</span><span class="sxs-lookup"><span data-stu-id="18c37-138">Performs an ordinal comparison.</span></span>|
|<xref:System.StringComparison.OrdinalIgnoreCase>|<span data-ttu-id="18c37-139">大文字と小文字を区別しない、序数に基づく比較を実行します。</span><span class="sxs-lookup"><span data-stu-id="18c37-139">Performs a case-insensitive ordinal comparison.</span></span>|

<span data-ttu-id="18c37-140">たとえば、文字または文字列に一致する <xref:System.String> オブジェクト内の部分文字列のインデックスを返す <xref:System.String.IndexOf%2A> メソッドには、次の 9 つのオーバーロードがあります。</span><span class="sxs-lookup"><span data-stu-id="18c37-140">For example, the <xref:System.String.IndexOf%2A> method, which returns the index of a substring in a <xref:System.String> object that matches either a character or a string, has nine overloads:</span></span>

- <span data-ttu-id="18c37-141"><xref:System.String.IndexOf%28System.Char%29>、 <xref:System.String.IndexOf%28System.Char%2CSystem.Int32%29>、および <xref:System.String.IndexOf%28System.Char%2CSystem.Int32%2CSystem.Int32%29>。文字列内の文字の序数に基づく (大文字と小文字を区別し、カルチャに依存しない) 検索を既定で実行します。</span><span class="sxs-lookup"><span data-stu-id="18c37-141"><xref:System.String.IndexOf%28System.Char%29>, <xref:System.String.IndexOf%28System.Char%2CSystem.Int32%29>, and <xref:System.String.IndexOf%28System.Char%2CSystem.Int32%2CSystem.Int32%29>, which by default perform an ordinal (case-sensitive and culture-insensitive) search for a character in the string.</span></span>
- <span data-ttu-id="18c37-142"><xref:System.String.IndexOf%28System.String%29>、 <xref:System.String.IndexOf%28System.String%2CSystem.Int32%29>、および <xref:System.String.IndexOf%28System.String%2CSystem.Int32%2CSystem.Int32%29>。文字列内の部分文字列の、大文字と小文字を区別し、カルチャに依存した検索を既定で実行します。</span><span class="sxs-lookup"><span data-stu-id="18c37-142"><xref:System.String.IndexOf%28System.String%29>, <xref:System.String.IndexOf%28System.String%2CSystem.Int32%29>, and <xref:System.String.IndexOf%28System.String%2CSystem.Int32%2CSystem.Int32%29>, which by default perform a case-sensitive and culture-sensitive search for a substring in the string.</span></span>
- <span data-ttu-id="18c37-143"><xref:System.String.IndexOf%28System.String%2CSystem.StringComparison%29>、 <xref:System.String.IndexOf%28System.String%2CSystem.Int32%2CSystem.StringComparison%29>、および <xref:System.String.IndexOf%28System.String%2CSystem.Int32%2CSystem.Int32%2CSystem.StringComparison%29>。比較の形式を指定できる <xref:System.StringComparison> 型のパラメーターが含まれています。</span><span class="sxs-lookup"><span data-stu-id="18c37-143"><xref:System.String.IndexOf%28System.String%2CSystem.StringComparison%29>, <xref:System.String.IndexOf%28System.String%2CSystem.Int32%2CSystem.StringComparison%29>, and <xref:System.String.IndexOf%28System.String%2CSystem.Int32%2CSystem.Int32%2CSystem.StringComparison%29>, which include a parameter of type <xref:System.StringComparison> that allows the form of the comparison to be specified.</span></span>

<span data-ttu-id="18c37-144">次のような理由から、既定値を使用しないオーバーロードを選択することをお勧めします。</span><span class="sxs-lookup"><span data-stu-id="18c37-144">We recommend that you select an overload that does not use default values, for the following reasons:</span></span>

- <span data-ttu-id="18c37-145">既定のパラメーターを持つオーバーロードには、序数に基づく比較を実行するもの (文字列インスタンスで <xref:System.Char> を検索するもの) と、カルチャに依存するもの (文字列インスタンスで文字列を検索するもの) があります。</span><span class="sxs-lookup"><span data-stu-id="18c37-145">Some overloads with default parameters (those that search for a <xref:System.Char> in the string instance) perform an ordinal comparison, whereas others (those that search for a string in the string instance) are culture-sensitive.</span></span> <span data-ttu-id="18c37-146">どのメソッドがどの既定値を使用するのかを覚えておくのは容易ではなく、使用するオーバーロードを間違えやすくなります。</span><span class="sxs-lookup"><span data-stu-id="18c37-146">It is difficult to remember which method uses which default value, and easy to confuse the overloads.</span></span>
- <span data-ttu-id="18c37-147">メソッド呼び出しで既定値に依存するコードは、意図が不明確になります。</span><span class="sxs-lookup"><span data-stu-id="18c37-147">The intent of the code that relies on default values for method calls is not clear.</span></span> <span data-ttu-id="18c37-148">既定値に依存する次の例では、2 つの文字列の序数に基づく比較と言語に基づく比較のどちらを開発者が意図しているのかや、`protocol` と "http" の大文字と小文字が違っていた場合に等価性テストで `false` を返すかどうかがわかりにくくなっています。</span><span class="sxs-lookup"><span data-stu-id="18c37-148">In the following example, which relies on defaults, it is difficult to know whether the developer actually intended an ordinal or a linguistic comparison of two strings, or whether a case difference between `protocol` and "http" might cause the test for equality to return `false`.</span></span>

     [!code-csharp[Conceptual.Strings.BestPractices#1](~/samples/snippets/csharp/VS_Snippets_CLR/conceptual.strings.bestpractices/cs/explicitargs1.cs#1)]
     [!code-vb[Conceptual.Strings.BestPractices#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/conceptual.strings.bestpractices/vb/explicitargs1.vb#1)]

<span data-ttu-id="18c37-149">一般的には、既定値に依存しないメソッドを呼び出すことをお勧めします。そうすると、コードの意図が明確になります。</span><span class="sxs-lookup"><span data-stu-id="18c37-149">In general, we recommend that you call a method that does not rely on defaults, because it makes the intent of the code unambiguous.</span></span> <span data-ttu-id="18c37-150">その結果、コードが読みやすくなるため、デバッグや保守も容易になります。</span><span class="sxs-lookup"><span data-stu-id="18c37-150">This, in turn, makes the code more readable and easier to debug and maintain.</span></span> <span data-ttu-id="18c37-151">次の例では、前の例で発生した問題に対応します。</span><span class="sxs-lookup"><span data-stu-id="18c37-151">The following example addresses the questions raised about the previous example.</span></span> <span data-ttu-id="18c37-152">序数比較を使用することと、大文字と小文字の違いを無視することを指定します。</span><span class="sxs-lookup"><span data-stu-id="18c37-152">It makes it clear that ordinal comparison is used and that differences in case are ignored.</span></span>

[!code-csharp[Conceptual.Strings.BestPractices#2](~/samples/snippets/csharp/VS_Snippets_CLR/conceptual.strings.bestpractices/cs/explicitargs1.cs#2)]
[!code-vb[Conceptual.Strings.BestPractices#2](~/samples/snippets/visualbasic/VS_Snippets_CLR/conceptual.strings.bestpractices/vb/explicitargs1.vb#2)]

## <a name="the-details-of-string-comparison"></a><span data-ttu-id="18c37-153">文字列比較の詳細</span><span class="sxs-lookup"><span data-stu-id="18c37-153">The details of string comparison</span></span>

<span data-ttu-id="18c37-154">文字列比較は、多くの文字列関連操作 (特に並べ替えおよび等価性テスト) の中核です。</span><span class="sxs-lookup"><span data-stu-id="18c37-154">String comparison is the heart of many string-related operations, particularly sorting and testing for equality.</span></span> <span data-ttu-id="18c37-155">文字列は、決まった順序で並べられています。たとえば、文字列の並べ替え済みリスト上で "my" が "string" の前にある場合、比較では必ず "my" が "string" 以下になります。</span><span class="sxs-lookup"><span data-stu-id="18c37-155">Strings sort in a determined order: If "my" appears before "string" in a sorted list of strings, "my" must compare less than or equal to "string".</span></span> <span data-ttu-id="18c37-156">また、比較は等価性を暗黙的に定義します。</span><span class="sxs-lookup"><span data-stu-id="18c37-156">Additionally, comparison implicitly defines equality.</span></span> <span data-ttu-id="18c37-157">比較演算では、等価と見なされた文字列に対して 0 が返されます。</span><span class="sxs-lookup"><span data-stu-id="18c37-157">The comparison operation returns zero for strings it deems equal.</span></span> <span data-ttu-id="18c37-158">これは、どちらの文字列ももう一方の文字列より小さくないという意味に解釈するとわかりやすくなります。</span><span class="sxs-lookup"><span data-stu-id="18c37-158">A good interpretation is that neither string is less than the other.</span></span> <span data-ttu-id="18c37-159">文字列に関係する、意味のある操作のほとんどには、他の文字列との比較か、正しく定義された並べ替え操作の実行のいずれかまたは両方の処理が含まれています。</span><span class="sxs-lookup"><span data-stu-id="18c37-159">Most meaningful operations involving strings include one or both of these procedures: comparing with another string, and executing a well-defined sort operation.</span></span>

> [!NOTE]
> <span data-ttu-id="18c37-160">Windows オペレーティング システムの並べ替え操作と比較操作で使用される文字の重みに関する情報を含む一連のテキスト ファイルである[並べ替え重みテーブル](https://www.microsoft.com/download/details.aspx?id=10921) と、Linux と macOS 用の並べ替え重みテーブルの最新バージョンである [デフォルト Unicode 照合基本テーブル](https://www.unicode.org/Public/UCA/latest/allkeys.txt)をダウンロードできます。</span><span class="sxs-lookup"><span data-stu-id="18c37-160">You can download the [Sorting Weight Tables](https://www.microsoft.com/download/details.aspx?id=10921), a set of text files that contain information on the character weights used in sorting and comparison operations for Windows operating systems, and the [Default Unicode Collation Element Table](https://www.unicode.org/Public/UCA/latest/allkeys.txt), the latest version of the sort weight table for Linux and macOS.</span></span> <span data-ttu-id="18c37-161">Linux と macOS での並べ替え重みのテーブルの特定のバージョンは、システムにインストールされている [International Components for Unicode](http://site.icu-project.org/) ライブラリのバージョンによって異なります。</span><span class="sxs-lookup"><span data-stu-id="18c37-161">The specific version of the sort weight table on Linux and macOS depends on the version of the [International Components for Unicode](http://site.icu-project.org/) libraries installed on the system.</span></span> <span data-ttu-id="18c37-162">実装される ICU のバージョンと Unicode のバージョンに関する情報は、[ICU のダウンロード](http://site.icu-project.org/download)に関する記事を参照してください。</span><span class="sxs-lookup"><span data-stu-id="18c37-162">For information on ICU versions and the Unicode versions that they implement, see [Downloading ICU](http://site.icu-project.org/download).</span></span>

<span data-ttu-id="18c37-163">しかし、2 つの文字列の等価性や並べ替え順序を評価する場合、正しい結果は 1 つではありません。結果は、文字列の比較に使用される基準に依存するためです。</span><span class="sxs-lookup"><span data-stu-id="18c37-163">However, evaluating two strings for equality or sort order does not yield a single, correct result; the outcome depends on the criteria used to compare the strings.</span></span> <span data-ttu-id="18c37-164">特に、序数に基づく文字列比較や、現在のカルチャまたは[インバリアント カルチャ](xref:System.Globalization.CultureInfo.InvariantCulture) (英語をベースとする、ロケールに依存しないカルチャ) の大文字と小文字の規則や並べ替えの規則に基づく文字列比較では、さまざまな結果が返される可能性があります。</span><span class="sxs-lookup"><span data-stu-id="18c37-164">In particular, string comparisons that are ordinal or that are based on the casing and sorting conventions of the current culture or the [invariant culture](xref:System.Globalization.CultureInfo.InvariantCulture) (a locale-agnostic culture based on the English language) may produce different results.</span></span>

<span data-ttu-id="18c37-165">さらに、文字列比較を、異なるバージョンの .NET を使用したり、異なるオペレーティング システムまたはバージョンが異なるオペレーティング システム上の .NET で実行したりすると、異なる結果が返る可能性があります。</span><span class="sxs-lookup"><span data-stu-id="18c37-165">In addition, string comparisons using different versions of .NET or using .NET on different operating systems or operating system versions may return different results.</span></span> <span data-ttu-id="18c37-166">詳細については、「[Strings and The Unicode Standard](xref:System.String#Unicode)」(文字列と Unicode 標準) を参照してください。</span><span class="sxs-lookup"><span data-stu-id="18c37-166">For more information, see [Strings and the Unicode Standard](xref:System.String#Unicode).</span></span>

### <a name="string-comparisons-that-use-the-current-culture"></a><span data-ttu-id="18c37-167">現在のカルチャを使用する文字列比較</span><span class="sxs-lookup"><span data-stu-id="18c37-167">String comparisons that use the current culture</span></span>

<span data-ttu-id="18c37-168">文字列を比較するときの基準として現在のカルチャの規則が使用される場合があります。</span><span class="sxs-lookup"><span data-stu-id="18c37-168">One criterion involves using the conventions of the current culture when comparing strings.</span></span> <span data-ttu-id="18c37-169">現在のカルチャに基づく比較では、スレッドの現在のカルチャ (ロケール) が使用されます。</span><span class="sxs-lookup"><span data-stu-id="18c37-169">Comparisons that are based on the current culture use the thread's current culture or locale.</span></span> <span data-ttu-id="18c37-170">ユーザーがカルチャを設定していない場合は、コントロール パネルの **[地域のオプション]** ウィンドウの設定が既定で使用されます。</span><span class="sxs-lookup"><span data-stu-id="18c37-170">If the culture is not set by the user, it defaults to the setting in the **Regional Options** window in Control Panel.</span></span> <span data-ttu-id="18c37-171">言語的な意味を持つデータや、カルチャに依存したユーザー操作を反映するデータに対しては、常に現在のカルチャに基づく比較を使用する必要があります。</span><span class="sxs-lookup"><span data-stu-id="18c37-171">You should always use comparisons that are based on the current culture when data is linguistically relevant, and when it reflects culture-sensitive user interaction.</span></span>

<span data-ttu-id="18c37-172">しかし、.NET の比較や大文字と小文字の区別の動作は、カルチャによって変わります。</span><span class="sxs-lookup"><span data-stu-id="18c37-172">However, comparison and casing behavior in .NET changes when the culture changes.</span></span> <span data-ttu-id="18c37-173">たとえば、開発されたコンピューターとは異なるカルチャのコンピューターでアプリケーションが実行された場合や、実行中のスレッドのカルチャが変更された場合などに、この変化が生じます。</span><span class="sxs-lookup"><span data-stu-id="18c37-173">This happens when an application executes on a computer that has a different culture than the computer on which the application was developed, or when the executing thread changes its culture.</span></span> <span data-ttu-id="18c37-174">これは意図的な動作ですが、多くの開発者にはまだあまり知られていません。</span><span class="sxs-lookup"><span data-stu-id="18c37-174">This behavior is intentional, but it remains non-obvious to many developers.</span></span> <span data-ttu-id="18c37-175">次の例は、英語 (米国) ("en-US") とスウェーデン語 ("sv-SE") のカルチャの並べ替え順序の違いを示しています。</span><span class="sxs-lookup"><span data-stu-id="18c37-175">The following example illustrates differences in sort order between the U.S. English ("en-US") and Swedish ("sv-SE") cultures.</span></span> <span data-ttu-id="18c37-176">並べ替えられた文字列配列で、"ångström"、"Windows"、および "Visual Studio" の位置が違っていることに注目してください。</span><span class="sxs-lookup"><span data-stu-id="18c37-176">Note that the words "ångström", "Windows", and "Visual Studio" appear in different positions in the sorted string arrays.</span></span>

[!code-csharp[Conceptual.Strings.BestPractices#3](~/samples/snippets/csharp/VS_Snippets_CLR/conceptual.strings.bestpractices/cs/comparison1.cs#3)]
[!code-vb[Conceptual.Strings.BestPractices#3](~/samples/snippets/visualbasic/VS_Snippets_CLR/conceptual.strings.bestpractices/vb/comparison1.vb#3)]

<span data-ttu-id="18c37-177">現在のカルチャを使用する、大文字と小文字を区別しない比較は、スレッドの現在のカルチャの大文字と小文字の区別の規則が無視される以外は、カルチャに依存した比較と同じです。</span><span class="sxs-lookup"><span data-stu-id="18c37-177">Case-insensitive comparisons that use the current culture are the same as culture-sensitive comparisons, except that they ignore case as dictated by the thread's current culture.</span></span> <span data-ttu-id="18c37-178">この動作も、並べ替え順序に影響する場合があります。</span><span class="sxs-lookup"><span data-stu-id="18c37-178">This behavior may manifest itself in sort orders as well.</span></span>

<span data-ttu-id="18c37-179">現在のカルチャのセマンティクスを使用する比較は、次のメソッドで既定で使用されます。</span><span class="sxs-lookup"><span data-stu-id="18c37-179">Comparisons that use current culture semantics are the default for the following methods:</span></span>

- <span data-ttu-id="18c37-180"><xref:System.StringComparison> パラメーターを含まない <xref:System.String.Compare%2A?displayProperty=nameWithType> のオーバーロード。</span><span class="sxs-lookup"><span data-stu-id="18c37-180"><xref:System.String.Compare%2A?displayProperty=nameWithType> overloads that do not include a <xref:System.StringComparison> parameter.</span></span>
- <span data-ttu-id="18c37-181"><xref:System.String.CompareTo%2A?displayProperty=nameWithType> のオーバーロード。</span><span class="sxs-lookup"><span data-stu-id="18c37-181"><xref:System.String.CompareTo%2A?displayProperty=nameWithType> overloads.</span></span>
- <span data-ttu-id="18c37-182">既定の <xref:System.String.StartsWith%28System.String%29?displayProperty=nameWithType> メソッドと、 <xref:System.String.StartsWith%28System.String%2CSystem.Boolean%2CSystem.Globalization.CultureInfo%29?displayProperty=nameWithType> null `null`<xref:System.Globalization.CultureInfo> のオーバーロード。</span><span class="sxs-lookup"><span data-stu-id="18c37-182">The default <xref:System.String.StartsWith%28System.String%29?displayProperty=nameWithType> method, and the <xref:System.String.StartsWith%28System.String%2CSystem.Boolean%2CSystem.Globalization.CultureInfo%29?displayProperty=nameWithType> method with a `null`<xref:System.Globalization.CultureInfo> parameter.</span></span>
- <span data-ttu-id="18c37-183">既定の <xref:System.String.EndsWith%28System.String%29?displayProperty=nameWithType> メソッドと、`null`<xref:System.Globalization.CultureInfo> パラメーターを持つ <xref:System.String.EndsWith%28System.String%2CSystem.Boolean%2CSystem.Globalization.CultureInfo%29?displayProperty=nameWithType> メソッド。</span><span class="sxs-lookup"><span data-stu-id="18c37-183">The default <xref:System.String.EndsWith%28System.String%29?displayProperty=nameWithType> method, and the <xref:System.String.EndsWith%28System.String%2CSystem.Boolean%2CSystem.Globalization.CultureInfo%29?displayProperty=nameWithType> method with a `null`<xref:System.Globalization.CultureInfo> parameter.</span></span>
- <span data-ttu-id="18c37-184">検索パラメーターとして<xref:System.String.IndexOf%2A?displayProperty=nameWithType> を受け取る、 <xref:System.String> パラメーターを持たない <xref:System.StringComparison> のオーバーロード。</span><span class="sxs-lookup"><span data-stu-id="18c37-184"><xref:System.String.IndexOf%2A?displayProperty=nameWithType> overloads that accept a <xref:System.String> as a search parameter and that do not have a <xref:System.StringComparison> parameter.</span></span>
- <span data-ttu-id="18c37-185">検索パラメーターとして <xref:System.String> を受け取る、<xref:System.StringComparison> パラメーターを持たない <xref:System.String.LastIndexOf%2A?displayProperty=nameWithType> のオーバーロード。</span><span class="sxs-lookup"><span data-stu-id="18c37-185"><xref:System.String.LastIndexOf%2A?displayProperty=nameWithType> overloads that accept a <xref:System.String> as a search parameter and that do not have a <xref:System.StringComparison> parameter.</span></span>

<span data-ttu-id="18c37-186">どのような場合でも、 <xref:System.StringComparison> パラメーターを持つオーバーロードを呼び出して、メソッド呼び出しの意図を明確にすることをお勧めします。</span><span class="sxs-lookup"><span data-stu-id="18c37-186">In any case, we recommend that you call an overload that has a <xref:System.StringComparison> parameter to make the intent of the method call clear.</span></span>

<span data-ttu-id="18c37-187">非言語的な文字列データが言語的に解釈されたり、特定のカルチャの文字列データが別のカルチャの規則で解釈されたりすると、軽度のバグやあまり軽度でないバグが発生する可能性があります。</span><span class="sxs-lookup"><span data-stu-id="18c37-187">Subtle and not so subtle bugs can emerge when non-linguistic string data is interpreted linguistically, or when string data from a particular culture is interpreted using the conventions of another culture.</span></span> <span data-ttu-id="18c37-188">その典型的な例が、トルコ語の I の問題です。</span><span class="sxs-lookup"><span data-stu-id="18c37-188">The canonical example is the Turkish-I problem.</span></span>

<span data-ttu-id="18c37-189">英語 (米国) を含むほぼすべてのラテン アルファベットでは、文字 "i" (\u0069) は "I" (\u0049) の小文字版です。</span><span class="sxs-lookup"><span data-stu-id="18c37-189">For nearly all Latin alphabets, including U.S. English, the character "i" (\u0069) is the lowercase version of the character "I" (\u0049).</span></span> <span data-ttu-id="18c37-190">この大文字と小文字の規則は、このようなカルチャでプログラミングを行う人にとってはすぐに当たり前のことになります。</span><span class="sxs-lookup"><span data-stu-id="18c37-190">This casing rule quickly becomes the default for someone programming in such a culture.</span></span> <span data-ttu-id="18c37-191">しかし、トルコ語 ("tr-TR") のアルファベットには、"i" の大文字版である "ドット付きの I" ("İ" (\u0130)) があります。</span><span class="sxs-lookup"><span data-stu-id="18c37-191">However, the Turkish ("tr-TR") alphabet includes an "I with a dot" character "İ" (\u0130), which is the capital version of "i".</span></span> <span data-ttu-id="18c37-192">大文字にすると "I" になる小文字の "ドットなしの i" ("ı" (\u0131)) もあります。</span><span class="sxs-lookup"><span data-stu-id="18c37-192">Turkish also includes a lowercase "i without a dot" character, "ı" (\u0131), which capitalizes to "I".</span></span> <span data-ttu-id="18c37-193">この動作は、アゼルバイジャン語 ("az") のカルチャでも発生します。</span><span class="sxs-lookup"><span data-stu-id="18c37-193">This behavior occurs in the Azerbaijani ("az") culture as well.</span></span>

<span data-ttu-id="18c37-194">したがって、"i" を大文字にしたり "I" を小文字にしたりする動作に関する前提は、すべてのカルチャで有効なわけではありません。</span><span class="sxs-lookup"><span data-stu-id="18c37-194">Therefore, assumptions made about capitalizing "i" or lowercasing "I" are not valid among all cultures.</span></span> <span data-ttu-id="18c37-195">文字列比較ルーチンの既定のオーバーロードを使用すると、カルチャ間の差異の影響を受けることになります。</span><span class="sxs-lookup"><span data-stu-id="18c37-195">If you use the default overloads for string comparison routines, they will be subject to variance between cultures.</span></span> <span data-ttu-id="18c37-196">また、非言語的なデータを比較する場合も、既定のオーバーロードを使用すると望ましくない結果が返される可能性があります。たとえば次の例では、文字列 "file" と "FILE" の大文字と小文字を区別しない比較を実行しようとしています。</span><span class="sxs-lookup"><span data-stu-id="18c37-196">If the data to be compared is non-linguistic, using the default overloads can produce undesirable results, as the following attempt to perform a case-insensitive comparison of the strings "file" and "FILE" illustrates.</span></span>

[!code-csharp[Conceptual.Strings.BestPractices#11](~/samples/snippets/csharp/VS_Snippets_CLR/conceptual.strings.bestpractices/cs/turkish1.cs#11)]
[!code-vb[Conceptual.Strings.BestPractices#11](~/samples/snippets/visualbasic/VS_Snippets_CLR/conceptual.strings.bestpractices/vb/turkish1.vb#11)]

<span data-ttu-id="18c37-197">この比較は、セキュリティが重要となる状況でカルチャが不注意に使用されると、次の例のような重大な問題を引き起こす可能性があります。</span><span class="sxs-lookup"><span data-stu-id="18c37-197">This comparison could cause significant problems if the culture is inadvertently used in security-sensitive settings, as in the following example.</span></span> <span data-ttu-id="18c37-198">`IsFileURI("file:")` などのメソッド呼び出しは、現在のカルチャが英語 (米国) の場合は `true` を返しますが、現在のカルチャがトルコ語の場合は `false` を返します。</span><span class="sxs-lookup"><span data-stu-id="18c37-198">A method call such as `IsFileURI("file:")` returns `true` if the current culture is U.S. English, but `false` if the current culture is Turkish.</span></span> <span data-ttu-id="18c37-199">したがって、"FILE:" で始まる URI へのアクセスを大文字と小文字の区別なくブロックするセキュリティ対策は、トルコ語のシステムでは攻略される可能性があります。</span><span class="sxs-lookup"><span data-stu-id="18c37-199">Thus, on Turkish systems, someone could circumvent security measures that block access to case-insensitive URIs that begin with "FILE:".</span></span>

[!code-csharp[Conceptual.Strings.BestPractices#12](~/samples/snippets/csharp/VS_Snippets_CLR/conceptual.strings.bestpractices/cs/turkish1.cs#12)]
[!code-vb[Conceptual.Strings.BestPractices#12](~/samples/snippets/visualbasic/VS_Snippets_CLR/conceptual.strings.bestpractices/vb/turkish1.vb#12)]

<span data-ttu-id="18c37-200">この例の "file:" は、カルチャに依存しない非言語的な識別子として解釈されるものなので、コードを次のように書き換える必要があります。</span><span class="sxs-lookup"><span data-stu-id="18c37-200">In this case, because "file:" is meant to be interpreted as a non-linguistic, culture-insensitive identifier, the code should instead be written as shown in the following example:</span></span>

[!code-csharp[Conceptual.Strings.BestPractices#13](~/samples/snippets/csharp/VS_Snippets_CLR/conceptual.strings.bestpractices/cs/turkish1.cs#13)]
[!code-vb[Conceptual.Strings.BestPractices#13](~/samples/snippets/visualbasic/VS_Snippets_CLR/conceptual.strings.bestpractices/vb/turkish1.vb#13)]

### <a name="ordinal-string-operations"></a><span data-ttu-id="18c37-201">序数に基づく文字列操作</span><span class="sxs-lookup"><span data-stu-id="18c37-201">Ordinal string operations</span></span>

<span data-ttu-id="18c37-202">メソッド呼び出しで <xref:System.StringComparison.Ordinal?displayProperty=nameWithType> 値または <xref:System.StringComparison.OrdinalIgnoreCase?displayProperty=nameWithType> 値を指定すると、非言語的な比較が行われ、自然言語の特性は無視されます。</span><span class="sxs-lookup"><span data-stu-id="18c37-202">Specifying the <xref:System.StringComparison.Ordinal?displayProperty=nameWithType> or <xref:System.StringComparison.OrdinalIgnoreCase?displayProperty=nameWithType> value in a method call signifies a non-linguistic comparison in which the features of natural languages are ignored.</span></span> <span data-ttu-id="18c37-203">これらの <xref:System.StringComparison> 値を使用して呼び出されたメソッドでは、文字列操作の判断が、大文字と小文字の指定、またはカルチャでパラメーター化される同等の表ではなく、単純なバイト比較に基づいて行われます。</span><span class="sxs-lookup"><span data-stu-id="18c37-203">Methods that are invoked with these <xref:System.StringComparison> values base string operation decisions on simple byte comparisons instead of casing or equivalence tables that are parameterized by culture.</span></span> <span data-ttu-id="18c37-204">これにより、ほとんどの場合に文字列が意図されたとおりに解釈され、コードの実行速度と信頼性も向上します。</span><span class="sxs-lookup"><span data-stu-id="18c37-204">In most cases, this approach best fits the intended interpretation of strings while making code faster and more reliable.</span></span>

<span data-ttu-id="18c37-205">序数に基づく比較とは、各文字列の各バイトが言語的に解釈されずに比較される文字列比較です (たとえば、"windows" と "Windows" は一致しません)。</span><span class="sxs-lookup"><span data-stu-id="18c37-205">Ordinal comparisons are string comparisons in which each byte of each string is compared without linguistic interpretation; for example, "windows" does not match "Windows".</span></span> <span data-ttu-id="18c37-206">これは、実質的には C ランタイムの `strcmp` 関数の呼び出しです。</span><span class="sxs-lookup"><span data-stu-id="18c37-206">This is essentially a call to the C runtime `strcmp` function.</span></span> <span data-ttu-id="18c37-207">文字列が厳密に一致する必要がある状況や、慎重な照合ポリシーが求められる状況では、この比較を使用します。</span><span class="sxs-lookup"><span data-stu-id="18c37-207">Use this comparison when the context dictates that strings should be matched exactly or demands conservative matching policy.</span></span> <span data-ttu-id="18c37-208">また、序数に基づく比較は最も高速な比較演算でもあります。これは、結果を判定するときに言語の規則が適用されないためです。</span><span class="sxs-lookup"><span data-stu-id="18c37-208">Additionally, ordinal comparison is the fastest comparison operation because it applies no linguistic rules when determining a result.</span></span>

<span data-ttu-id="18c37-209">.NET の文字列には、null 文字が埋め込まれる場合があります。</span><span class="sxs-lookup"><span data-stu-id="18c37-209">Strings in .NET can contain embedded null characters.</span></span> <span data-ttu-id="18c37-210">序数に基づく比較とカルチャに依存した比較 (インバリアント カルチャを使用する比較を含む) の最も明白な違いの 1 つは、文字列に埋め込まれた null 文字の処理に関連しています。</span><span class="sxs-lookup"><span data-stu-id="18c37-210">One of the clearest differences between ordinal and culture-sensitive comparison (including comparisons that use the invariant culture) concerns the handling of embedded null characters in a string.</span></span> <span data-ttu-id="18c37-211">これらの文字は、<xref:System.String.Compare%2A?displayProperty=nameWithType> メソッドや <xref:System.String.Equals%2A?displayProperty=nameWithType> メソッドを使用して、カルチャに依存した比較 (インバリアント カルチャを使用する比較を含む) を実行する場合には無視されます。</span><span class="sxs-lookup"><span data-stu-id="18c37-211">These characters are ignored when you use the <xref:System.String.Compare%2A?displayProperty=nameWithType> and <xref:System.String.Equals%2A?displayProperty=nameWithType> methods to perform culture-sensitive comparisons (including comparisons that use the invariant culture).</span></span> <span data-ttu-id="18c37-212">その結果、カルチャに依存した比較では、null 文字が埋め込まれた文字列と null 文字が埋め込まれていない文字列が等価と見なされる可能性があります。</span><span class="sxs-lookup"><span data-stu-id="18c37-212">As a result, in culture-sensitive comparisons, strings that contain embedded null characters can be considered equal to strings that do not.</span></span>

> [!IMPORTANT]
> <span data-ttu-id="18c37-213">埋め込まれた null 文字は、文字列比較メソッドでは無視されますが、文字列検索メソッド (<xref:System.String.Contains%2A?displayProperty=nameWithType>、<xref:System.String.EndsWith%2A?displayProperty=nameWithType>、<xref:System.String.IndexOf%2A?displayProperty=nameWithType>、<xref:System.String.LastIndexOf%2A?displayProperty=nameWithType>、<xref:System.String.StartsWith%2A?displayProperty=nameWithType> など) では無視されません。</span><span class="sxs-lookup"><span data-stu-id="18c37-213">Although string comparison methods disregard embedded null characters, string search methods such as <xref:System.String.Contains%2A?displayProperty=nameWithType>, <xref:System.String.EndsWith%2A?displayProperty=nameWithType>, <xref:System.String.IndexOf%2A?displayProperty=nameWithType>, <xref:System.String.LastIndexOf%2A?displayProperty=nameWithType>, and <xref:System.String.StartsWith%2A?displayProperty=nameWithType> do not.</span></span>

<span data-ttu-id="18c37-214">次の例では、文字列 "Aa" と、"A" と "a" の間にいくつかの null 文字が埋め込まれた類似の文字列とのカルチャに依存した比較を実行して、2 つの文字列が等価と見なされることを示しています。</span><span class="sxs-lookup"><span data-stu-id="18c37-214">The following example performs a culture-sensitive comparison of the string "Aa" with a similar string that contains several embedded null characters between "A" and "a", and shows how the two strings are considered equal:</span></span>

[!code-csharp[Conceptual.Strings.BestPractices#19](~/samples/snippets/csharp/VS_Snippets_CLR/conceptual.strings.bestpractices/cs/embeddednulls1.cs#19)]
 [!code-vb[Conceptual.Strings.BestPractices#19](~/samples/snippets/visualbasic/VS_Snippets_CLR/conceptual.strings.bestpractices/vb/embeddednulls1.vb#19)]

<span data-ttu-id="18c37-215">一方、次の例のように序数に基づく比較を使用すると、これらの文字列は等価とは見なされません。</span><span class="sxs-lookup"><span data-stu-id="18c37-215">However, the strings are not considered equal when you use ordinal comparison, as the following example shows:</span></span>

[!code-csharp[Conceptual.Strings.BestPractices#20](~/samples/snippets/csharp/VS_Snippets_CLR/conceptual.strings.bestpractices/cs/embeddednulls2.cs#20)]
[!code-vb[Conceptual.Strings.BestPractices#20](~/samples/snippets/visualbasic/VS_Snippets_CLR/conceptual.strings.bestpractices/vb/embeddednulls2.vb#20)]

<span data-ttu-id="18c37-216">その次に慎重な方法は、大文字と小文字を区別しない序数に基づく比較です。</span><span class="sxs-lookup"><span data-stu-id="18c37-216">Case-insensitive ordinal comparisons are the next most conservative approach.</span></span> <span data-ttu-id="18c37-217">この比較では、大文字と小文字の区別のほとんどが無視されます (たとえば、"windows" と "Windows" は一致します)。</span><span class="sxs-lookup"><span data-stu-id="18c37-217">These comparisons ignore most casing; for example, "windows" matches "Windows".</span></span> <span data-ttu-id="18c37-218">ASCII 文字を操作する場合、このポリシーは <xref:System.StringComparison.Ordinal?displayProperty=nameWithType> と同等ですが、通常の ASCII の大文字と小文字の区別が無視されます。</span><span class="sxs-lookup"><span data-stu-id="18c37-218">When dealing with ASCII characters, this policy is equivalent to <xref:System.StringComparison.Ordinal?displayProperty=nameWithType>, except that it ignores the usual ASCII casing.</span></span> <span data-ttu-id="18c37-219">したがって、[A, Z] (\u0041-\u005A) の任意の文字が [a,z] (\u0061-\007A) の対応する文字と一致します。</span><span class="sxs-lookup"><span data-stu-id="18c37-219">Therefore, any character in [A, Z] (\u0041-\u005A) matches the corresponding character in [a,z] (\u0061-\007A).</span></span> <span data-ttu-id="18c37-220">ASCII の範囲外の大文字と小文字の区別には、インバリアント カルチャのテーブルが使用されます。</span><span class="sxs-lookup"><span data-stu-id="18c37-220">Casing outside the ASCII range uses the invariant culture's tables.</span></span> <span data-ttu-id="18c37-221">次に例を示します。</span><span class="sxs-lookup"><span data-stu-id="18c37-221">Therefore, the following comparison:</span></span>

[!code-csharp[Conceptual.Strings.BestPractices#4](~/samples/snippets/csharp/VS_Snippets_CLR/conceptual.strings.bestpractices/cs/comparison2.cs#4)]
[!code-vb[Conceptual.Strings.BestPractices#4](~/samples/snippets/visualbasic/VS_Snippets_CLR/conceptual.strings.bestpractices/vb/comparison2.vb#4)]

<span data-ttu-id="18c37-222">この比較は、次の比較と同等です (ただし、より高速です)。</span><span class="sxs-lookup"><span data-stu-id="18c37-222">is equivalent to (but faster than) this comparison:</span></span>

[!code-csharp[Conceptual.Strings.BestPractices#5](~/samples/snippets/csharp/VS_Snippets_CLR/conceptual.strings.bestpractices/cs/comparison2.cs#5)]
[!code-vb[Conceptual.Strings.BestPractices#5](~/samples/snippets/visualbasic/VS_Snippets_CLR/conceptual.strings.bestpractices/vb/comparison2.vb#5)]

<span data-ttu-id="18c37-223">とはいえ、これらの比較はどちらも非常に高速です。</span><span class="sxs-lookup"><span data-stu-id="18c37-223">These comparisons are still very fast.</span></span>

> [!NOTE]
> <span data-ttu-id="18c37-224">ファイル システム、レジストリのキーと値、および環境変数の文字列の動作は、<xref:System.StringComparison.OrdinalIgnoreCase?displayProperty=nameWithType> によって最もよく表現されます。</span><span class="sxs-lookup"><span data-stu-id="18c37-224">The string behavior of the file system, registry keys and values, and environment variables is best represented by <xref:System.StringComparison.OrdinalIgnoreCase?displayProperty=nameWithType>.</span></span>

<span data-ttu-id="18c37-225"><xref:System.StringComparison.Ordinal?displayProperty=nameWithType> と <xref:System.StringComparison.OrdinalIgnoreCase?displayProperty=nameWithType> は、どちらもバイナリ値を直接使用するため、照合に最適です。</span><span class="sxs-lookup"><span data-stu-id="18c37-225">Both <xref:System.StringComparison.Ordinal?displayProperty=nameWithType> and <xref:System.StringComparison.OrdinalIgnoreCase?displayProperty=nameWithType> use the binary values directly, and are best suited for matching.</span></span> <span data-ttu-id="18c37-226">比較の設定について確信を持てない場合は、この 2 つのいずれかの値を使用してください。</span><span class="sxs-lookup"><span data-stu-id="18c37-226">When you are not sure about your comparison settings, use one of these two values.</span></span> <span data-ttu-id="18c37-227">ただし、これらの値を使用するとバイトごとの比較が行われるため、言語的な順序 (英語の辞書のような順序) ではなくバイナリの順序で並べ替えが行われます。</span><span class="sxs-lookup"><span data-stu-id="18c37-227">However, because they perform a byte-by-byte comparison, they do not sort by a linguistic sort order (like an English dictionary) but by a binary sort order.</span></span> <span data-ttu-id="18c37-228">したがって、結果をユーザーに表示すると、ほとんどの場合不自然に見えます。</span><span class="sxs-lookup"><span data-stu-id="18c37-228">The results may look odd in most contexts if displayed to users.</span></span>

<span data-ttu-id="18c37-229">序数に基づくセマンティクスは、<xref:System.StringComparison> 引数を含まない <xref:System.String.Equals%2A?displayProperty=nameWithType> のオーバーロード (等値演算子を含む) で既定で使用されます。</span><span class="sxs-lookup"><span data-stu-id="18c37-229">Ordinal semantics are the default for <xref:System.String.Equals%2A?displayProperty=nameWithType> overloads that do not include a <xref:System.StringComparison> argument (including the equality operator).</span></span> <span data-ttu-id="18c37-230">どのような場合でも、 <xref:System.StringComparison> パラメーターを持つオーバーロードを呼び出すことをお勧めします。</span><span class="sxs-lookup"><span data-stu-id="18c37-230">In any case, we recommend that you call an overload that has a <xref:System.StringComparison> parameter.</span></span>

### <a name="string-operations-that-use-the-invariant-culture"></a><span data-ttu-id="18c37-231">インバリアント カルチャを使用する文字列操作</span><span class="sxs-lookup"><span data-stu-id="18c37-231">String operations that use the invariant culture</span></span>

<span data-ttu-id="18c37-232">インバリアント カルチャを使用する比較では、静的 <xref:System.Globalization.CultureInfo.InvariantCulture%2A?displayProperty=nameWithType> プロパティから返される <xref:System.Globalization.CultureInfo.CompareInfo%2A> プロパティが使用されます。</span><span class="sxs-lookup"><span data-stu-id="18c37-232">Comparisons with the invariant culture use the <xref:System.Globalization.CultureInfo.CompareInfo%2A> property returned by the static <xref:System.Globalization.CultureInfo.InvariantCulture%2A?displayProperty=nameWithType> property.</span></span> <span data-ttu-id="18c37-233">この動作は、すべてのシステムで同じです。範囲外の文字は、等価のインバリアント文字と見なされる文字に変換されます。</span><span class="sxs-lookup"><span data-stu-id="18c37-233">This behavior is the same on all systems; it translates any characters outside its range into what it believes are equivalent invariant characters.</span></span> <span data-ttu-id="18c37-234">このポリシーは、同じ文字列動作のセットを複数のカルチャにわたって保持する場合に便利ですが、予期しない結果になることもよくあります。</span><span class="sxs-lookup"><span data-stu-id="18c37-234">This policy can be useful for maintaining one set of string behavior across cultures, but it often provides unexpected results.</span></span>

<span data-ttu-id="18c37-235">インバリアント カルチャを使用する、大文字と小文字を区別しない比較でも、静的 <xref:System.Globalization.CultureInfo.InvariantCulture%2A?displayProperty=nameWithType> プロパティから返される静的 <xref:System.Globalization.CultureInfo.CompareInfo%2A> プロパティが比較情報として使用されます。</span><span class="sxs-lookup"><span data-stu-id="18c37-235">Case-insensitive comparisons with the invariant culture use the static <xref:System.Globalization.CultureInfo.CompareInfo%2A> property returned by the static <xref:System.Globalization.CultureInfo.InvariantCulture%2A?displayProperty=nameWithType> property for comparison information as well.</span></span> <span data-ttu-id="18c37-236">変換後の文字の大文字と小文字の違いは無視されます。</span><span class="sxs-lookup"><span data-stu-id="18c37-236">Any case differences among these translated characters are ignored.</span></span>

<span data-ttu-id="18c37-237"><xref:System.StringComparison.InvariantCulture?displayProperty=nameWithType> を使用する比較と <xref:System.StringComparison.Ordinal?displayProperty=nameWithType> を使用する比較は、ASCII 文字列に対して同じように動作します。</span><span class="sxs-lookup"><span data-stu-id="18c37-237">Comparisons that use <xref:System.StringComparison.InvariantCulture?displayProperty=nameWithType> and <xref:System.StringComparison.Ordinal?displayProperty=nameWithType> work identically on ASCII strings.</span></span> <span data-ttu-id="18c37-238">ただし、<xref:System.StringComparison.InvariantCulture?displayProperty=nameWithType> では言語的な判断が下されるため、バイト セットとして解釈する必要がある文字列に対しては不適切になることがあります。</span><span class="sxs-lookup"><span data-stu-id="18c37-238">However, <xref:System.StringComparison.InvariantCulture?displayProperty=nameWithType> makes linguistic decisions that might not be appropriate for strings that have to be interpreted as a set of bytes.</span></span> <span data-ttu-id="18c37-239">`CultureInfo.InvariantCulture.CompareInfo` オブジェクトのために <xref:System.String.Compare%2A> メソッドで特定の文字のセットが等価と解釈されることもあります。</span><span class="sxs-lookup"><span data-stu-id="18c37-239">The `CultureInfo.InvariantCulture.CompareInfo` object makes the <xref:System.String.Compare%2A> method interpret certain sets of characters as equivalent.</span></span> <span data-ttu-id="18c37-240">たとえば、次の例が等価になるのは、インバリアント カルチャでは妥当です。</span><span class="sxs-lookup"><span data-stu-id="18c37-240">For example, the following equivalence is valid under the invariant culture:</span></span>

<span data-ttu-id="18c37-241">InvariantCulture: a + ̊ = å</span><span class="sxs-lookup"><span data-stu-id="18c37-241">InvariantCulture: a + ̊ = å</span></span>

<span data-ttu-id="18c37-242">LATIN SMALL LETTER A 文字 "a" (\u0061) は、COMBINING RING ABOVE 文字 "+ " ̊" (\u030a) の横にある場合、LATIN SMALL LETTER A WITH RING ABOVE 文字 "å" (\u00e5) として解釈されます。</span><span class="sxs-lookup"><span data-stu-id="18c37-242">The LATIN SMALL LETTER A character "a"  (\u0061), when it is next to the COMBINING RING ABOVE character "+ " ̊" (\u030a), is interpreted as the LATIN SMALL LETTER A WITH RING ABOVE character "å" (\u00e5).</span></span> <span data-ttu-id="18c37-243">この動作は、次の例に示すように、序数に基づく比較とは異なります。</span><span class="sxs-lookup"><span data-stu-id="18c37-243">As the following example shows, this behavior differs from ordinal comparison.</span></span>

[!code-csharp[Conceptual.Strings.BestPractices#15](~/samples/snippets/csharp/VS_Snippets_CLR/conceptual.strings.bestpractices/cs/comparison3.cs#15)]
[!code-vb[Conceptual.Strings.BestPractices#15](~/samples/snippets/visualbasic/VS_Snippets_CLR/conceptual.strings.bestpractices/vb/comparison3.vb#15)]

<span data-ttu-id="18c37-244">ファイル名やクッキーなど、"å" のような組み合わせが出現する可能性がある要素を解釈する場合にも、序数に基づく比較を使用するのが最も明確かつ適切な方法になります。</span><span class="sxs-lookup"><span data-stu-id="18c37-244">When interpreting file names, cookies, or anything else where a combination such as "å" can appear, ordinal comparisons still offer the most transparent and fitting behavior.</span></span>

<span data-ttu-id="18c37-245">結局のところ、インバリアント カルチャには、比較に使用する際に便利なプロパティがほとんどありません。</span><span class="sxs-lookup"><span data-stu-id="18c37-245">On balance, the invariant culture has very few properties that make it useful for comparison.</span></span> <span data-ttu-id="18c37-246">インバリアント カルチャを使用すると、言語的な意味を持つ形で比較が行われるため、記号の完全な等価性は保証されません。その一方で、特定のカルチャでの表示にも適していません。</span><span class="sxs-lookup"><span data-stu-id="18c37-246">It does comparison in a linguistically relevant manner, which prevents it from guaranteeing full symbolic equivalence, but it is not the choice for display in any culture.</span></span> <span data-ttu-id="18c37-247"><xref:System.StringComparison.InvariantCulture?displayProperty=nameWithType> を比較に使用する数少ない理由の 1 つは、順序付けされたデータを複数のカルチャで同じように表示するために永続化できることです。</span><span class="sxs-lookup"><span data-stu-id="18c37-247">One of the few reasons to use <xref:System.StringComparison.InvariantCulture?displayProperty=nameWithType> for comparison is to persist ordered data for a cross-culturally identical display.</span></span> <span data-ttu-id="18c37-248">たとえば、表示する並べ替え済みの識別子のリストを含む大きなデータ ファイルがアプリケーションに付属している場合に、そのリストにエントリを追加するには、インバリアント スタイルの並べ替えを使用する挿入が必要になります。</span><span class="sxs-lookup"><span data-stu-id="18c37-248">For example, if a large data file that contains a list of sorted identifiers for display accompanies an application, adding to this list would require an insertion with invariant-style sorting.</span></span>

## <a name="choosing-a-stringcomparison-member-for-your-method-call"></a><span data-ttu-id="18c37-249">メソッド呼び出しに使用する StringComparison メンバーの選択</span><span class="sxs-lookup"><span data-stu-id="18c37-249">Choosing a StringComparison member for your method call</span></span>

<span data-ttu-id="18c37-250">文字列のセマンティックなコンテキストと <xref:System.StringComparison> 列挙型のメンバーとの対応関係の概要を次の表に示します。</span><span class="sxs-lookup"><span data-stu-id="18c37-250">The following table outlines the mapping from semantic string context to a <xref:System.StringComparison> enumeration member:</span></span>

|<span data-ttu-id="18c37-251">データ</span><span class="sxs-lookup"><span data-stu-id="18c37-251">Data</span></span>|<span data-ttu-id="18c37-252">動作</span><span class="sxs-lookup"><span data-stu-id="18c37-252">Behavior</span></span>|<span data-ttu-id="18c37-253">対応する System.StringComparison</span><span class="sxs-lookup"><span data-stu-id="18c37-253">Corresponding System.StringComparison</span></span><br /><br /> <span data-ttu-id="18c37-254">値</span><span class="sxs-lookup"><span data-stu-id="18c37-254">value</span></span>|
|----------|--------------|-----------------------------------------------------|
|<span data-ttu-id="18c37-255">大文字と小文字が区別される内部識別子。</span><span class="sxs-lookup"><span data-stu-id="18c37-255">Case-sensitive internal identifiers.</span></span><br /><br /> <span data-ttu-id="18c37-256">XML や HTTP などの標準の、大文字と小文字が区別される識別子。</span><span class="sxs-lookup"><span data-stu-id="18c37-256">Case-sensitive identifiers in standards such as XML and HTTP.</span></span><br /><br /> <span data-ttu-id="18c37-257">大文字と小文字が区別されるセキュリティ関連の設定。</span><span class="sxs-lookup"><span data-stu-id="18c37-257">Case-sensitive security-related settings.</span></span>|<span data-ttu-id="18c37-258">バイトが正確に一致する非言語的識別子。</span><span class="sxs-lookup"><span data-stu-id="18c37-258">A non-linguistic identifier, where bytes match exactly.</span></span>|<xref:System.StringComparison.Ordinal>|
|<span data-ttu-id="18c37-259">大文字と小文字が区別されない内部識別子。</span><span class="sxs-lookup"><span data-stu-id="18c37-259">Case-insensitive internal identifiers.</span></span><br /><br /> <span data-ttu-id="18c37-260">XML や HTTP などの標準の、大文字と小文字が区別されない識別子。</span><span class="sxs-lookup"><span data-stu-id="18c37-260">Case-insensitive identifiers in standards such as XML and HTTP.</span></span><br /><br /> <span data-ttu-id="18c37-261">ファイル パス。</span><span class="sxs-lookup"><span data-stu-id="18c37-261">File paths.</span></span><br /><br /> <span data-ttu-id="18c37-262">レジストリのキーと値。</span><span class="sxs-lookup"><span data-stu-id="18c37-262">Registry keys and values.</span></span><br /><br /> <span data-ttu-id="18c37-263">環境変数。</span><span class="sxs-lookup"><span data-stu-id="18c37-263">Environment variables.</span></span><br /><br /> <span data-ttu-id="18c37-264">リソース識別子 (ハンドル名など)。</span><span class="sxs-lookup"><span data-stu-id="18c37-264">Resource identifiers (for example, handle names).</span></span><br /><br /> <span data-ttu-id="18c37-265">大文字と小文字が区別されないセキュリティ関連の設定。</span><span class="sxs-lookup"><span data-stu-id="18c37-265">Case-insensitive security-related settings.</span></span>|<span data-ttu-id="18c37-266">大文字と小文字が区別されない、言語的な意味を持たない識別子 (ほとんどの Windows システム サービスで格納されるデータなど)。</span><span class="sxs-lookup"><span data-stu-id="18c37-266">A non-linguistic identifier, where case is irrelevant; especially data stored in most Windows system services.</span></span>|<xref:System.StringComparison.OrdinalIgnoreCase>|
|<span data-ttu-id="18c37-267">永続化される、言語的な意味を持つデータの一部。</span><span class="sxs-lookup"><span data-stu-id="18c37-267">Some persisted, linguistically relevant data.</span></span><br /><br /> <span data-ttu-id="18c37-268">一定の並べ替え順序を必要とする言語的なデータの表示。</span><span class="sxs-lookup"><span data-stu-id="18c37-268">Display of linguistic data that requires a fixed sort order.</span></span>|<span data-ttu-id="18c37-269">カルチャに依存しないが、言語的な意味を持つデータ。</span><span class="sxs-lookup"><span data-stu-id="18c37-269">Culturally agnostic data that still is linguistically relevant.</span></span>|<xref:System.StringComparison.InvariantCulture><br /><br /> <span data-ttu-id="18c37-270">\- または -</span><span class="sxs-lookup"><span data-stu-id="18c37-270">-or-</span></span><br /><br /> <xref:System.StringComparison.InvariantCultureIgnoreCase>|
|<span data-ttu-id="18c37-271">ユーザーに表示されるデータ。</span><span class="sxs-lookup"><span data-stu-id="18c37-271">Data displayed to the user.</span></span><br /><br /> <span data-ttu-id="18c37-272">ほとんどのユーザー入力。</span><span class="sxs-lookup"><span data-stu-id="18c37-272">Most user input.</span></span>|<span data-ttu-id="18c37-273">特定の言語の規則を必要とするデータ。</span><span class="sxs-lookup"><span data-stu-id="18c37-273">Data that requires local linguistic customs.</span></span>|<xref:System.StringComparison.CurrentCulture><br /><br /> <span data-ttu-id="18c37-274">\- または -</span><span class="sxs-lookup"><span data-stu-id="18c37-274">-or-</span></span><br /><br /> <xref:System.StringComparison.CurrentCultureIgnoreCase>|

## <a name="common-string-comparison-methods-in-net"></a><span data-ttu-id="18c37-275">.NET の一般的な文字列比較メソッド</span><span class="sxs-lookup"><span data-stu-id="18c37-275">Common string comparison methods in .NET</span></span>

<span data-ttu-id="18c37-276">以降では、文字列比較でよく使用されるメソッドについて説明します。</span><span class="sxs-lookup"><span data-stu-id="18c37-276">The following sections describe the methods that are most commonly used for string comparison.</span></span>

### <a name="stringcompare"></a><span data-ttu-id="18c37-277">String.Compare</span><span class="sxs-lookup"><span data-stu-id="18c37-277">String.Compare</span></span>

<span data-ttu-id="18c37-278">既定の解釈: <xref:System.StringComparison.CurrentCulture?displayProperty=nameWithType></span><span class="sxs-lookup"><span data-stu-id="18c37-278">Default interpretation: <xref:System.StringComparison.CurrentCulture?displayProperty=nameWithType>.</span></span>

<span data-ttu-id="18c37-279">このメソッドは文字列解釈の中心的な操作となるため、メソッド呼び出しのすべてのインスタンスを調べて、文字列を現在のカルチャに従って解釈するべきか、カルチャから切り離して (記号として) 扱うべきかどうかを確認する必要があります。</span><span class="sxs-lookup"><span data-stu-id="18c37-279">As the operation most central to string interpretation, all instances of these method calls should be examined to determine whether strings should be interpreted according to the current culture, or dissociated from the culture (symbolically).</span></span> <span data-ttu-id="18c37-280">ほとんどは後者であるため、その場合は代わりに <xref:System.StringComparison.Ordinal?displayProperty=nameWithType> の比較を使用します。</span><span class="sxs-lookup"><span data-stu-id="18c37-280">Typically, it is the latter, and a <xref:System.StringComparison.Ordinal?displayProperty=nameWithType> comparison should be used instead.</span></span>

<span data-ttu-id="18c37-281"><xref:System.Globalization.CultureInfo.CompareInfo%2A?displayProperty=nameWithType> プロパティから返される <xref:System.Globalization.CompareInfo?displayProperty=nameWithType> クラスにも、<xref:System.Globalization.CompareOptions> フラグ列挙体でさまざまな照合方法 (序数に基づく、空白文字を無視する、カナ型を無視するなど) を指定できる <xref:System.Globalization.CompareInfo.Compare%2A> メソッドが含まれています。</span><span class="sxs-lookup"><span data-stu-id="18c37-281">The <xref:System.Globalization.CompareInfo?displayProperty=nameWithType> class, which is returned by the <xref:System.Globalization.CultureInfo.CompareInfo%2A?displayProperty=nameWithType> property, also includes a <xref:System.Globalization.CompareInfo.Compare%2A> method that provides a large number of matching options (ordinal, ignoring white space, ignoring kana type, and so on) by means of the <xref:System.Globalization.CompareOptions> flag enumeration.</span></span>

### <a name="stringcompareto"></a><span data-ttu-id="18c37-282">String.CompareTo</span><span class="sxs-lookup"><span data-stu-id="18c37-282">String.CompareTo</span></span>

<span data-ttu-id="18c37-283">既定の解釈: <xref:System.StringComparison.CurrentCulture?displayProperty=nameWithType></span><span class="sxs-lookup"><span data-stu-id="18c37-283">Default interpretation: <xref:System.StringComparison.CurrentCulture?displayProperty=nameWithType>.</span></span>

<span data-ttu-id="18c37-284">このメソッドには、現時点では、<xref:System.StringComparison> 型を指定するオーバーロードはありません。</span><span class="sxs-lookup"><span data-stu-id="18c37-284">This method does not currently offer an overload that specifies a <xref:System.StringComparison> type.</span></span> <span data-ttu-id="18c37-285">通常は、このメソッドを推奨される <xref:System.String.Compare%28System.String%2CSystem.String%2CSystem.StringComparison%29?displayProperty=nameWithType> の形式に変換できます。</span><span class="sxs-lookup"><span data-stu-id="18c37-285">It is usually possible to convert this method to the recommended <xref:System.String.Compare%28System.String%2CSystem.String%2CSystem.StringComparison%29?displayProperty=nameWithType> form.</span></span>

<span data-ttu-id="18c37-286">このメソッドは、 <xref:System.IComparable> インターフェイスと <xref:System.IComparable%601> インターフェイスを実装する型に実装されます。</span><span class="sxs-lookup"><span data-stu-id="18c37-286">Types that implement the <xref:System.IComparable> and <xref:System.IComparable%601> interfaces implement this method.</span></span> <span data-ttu-id="18c37-287">このメソッドには <xref:System.StringComparison> パラメーターのオプションがないため、実装する型のコンストラクターで <xref:System.StringComparer> を指定できるようにするのが一般的です。</span><span class="sxs-lookup"><span data-stu-id="18c37-287">Because it does not offer the option of a <xref:System.StringComparison> parameter, implementing types often let the user specify a <xref:System.StringComparer> in their constructor.</span></span> <span data-ttu-id="18c37-288">次の例では、クラス コンストラクターに <xref:System.StringComparer> パラメーターを含む `FileName` クラスを定義しています。</span><span class="sxs-lookup"><span data-stu-id="18c37-288">The following example defines a `FileName` class whose class constructor includes a <xref:System.StringComparer> parameter.</span></span> <span data-ttu-id="18c37-289">この <xref:System.StringComparer> オブジェクトは、その後、 `FileName.CompareTo` メソッドで使用されています。</span><span class="sxs-lookup"><span data-stu-id="18c37-289">This <xref:System.StringComparer> object is then used in the `FileName.CompareTo` method.</span></span>

[!code-csharp[Conceptual.Strings.BestPractices#6](~/samples/snippets/csharp/VS_Snippets_CLR/conceptual.strings.bestpractices/cs/api1.cs#6)]
[!code-vb[Conceptual.Strings.BestPractices#6](~/samples/snippets/visualbasic/VS_Snippets_CLR/conceptual.strings.bestpractices/vb/api1.vb#6)]

### <a name="stringequals"></a><span data-ttu-id="18c37-290">String.Equals</span><span class="sxs-lookup"><span data-stu-id="18c37-290">String.Equals</span></span>

<span data-ttu-id="18c37-291">既定の解釈: <xref:System.StringComparison.Ordinal?displayProperty=nameWithType></span><span class="sxs-lookup"><span data-stu-id="18c37-291">Default interpretation: <xref:System.StringComparison.Ordinal?displayProperty=nameWithType>.</span></span>

<span data-ttu-id="18c37-292"><xref:System.String> クラスで等価性テストを実行するには、 <xref:System.String.Equals%2A> メソッド (静的メソッドまたはインスタンス メソッド) のオーバーロードを呼び出すか、静的等値演算子を使用します。</span><span class="sxs-lookup"><span data-stu-id="18c37-292">The <xref:System.String> class lets you test for equality by calling either the static or instance <xref:System.String.Equals%2A> method overloads, or by using the static equality operator.</span></span> <span data-ttu-id="18c37-293">これらのオーバーロードと演算子では、序数に基づく比較が既定で使用されます。</span><span class="sxs-lookup"><span data-stu-id="18c37-293">The overloads and operator use ordinal comparison by default.</span></span> <span data-ttu-id="18c37-294">しかし、序数に基づく比較を実行する場合でも、<xref:System.StringComparison> 型を明示的に指定するオーバーロードを呼び出すことをお勧めします。これにより、特定の文字列解釈のコードを検索しやすくなります。</span><span class="sxs-lookup"><span data-stu-id="18c37-294">However, we still recommend that you call an overload that explicitly specifies the <xref:System.StringComparison> type even if you want to perform an ordinal comparison; this makes it easier to search code for a certain string interpretation.</span></span>

### <a name="stringtoupper-and-stringtolower"></a><span data-ttu-id="18c37-295">String.ToUpper と String.ToLower</span><span class="sxs-lookup"><span data-stu-id="18c37-295">String.ToUpper and String.ToLower</span></span>

<span data-ttu-id="18c37-296">既定の解釈: <xref:System.StringComparison.CurrentCulture?displayProperty=nameWithType></span><span class="sxs-lookup"><span data-stu-id="18c37-296">Default interpretation: <xref:System.StringComparison.CurrentCulture?displayProperty=nameWithType>.</span></span>

<span data-ttu-id="18c37-297">これらのメソッドを使用するときには注意が必要です。というのも、文字列を大文字や小文字に強制的に変換する操作は、文字列を大文字と小文字の区別に関係なく比較するための小規模の正規化としてよく使用されるからです。</span><span class="sxs-lookup"><span data-stu-id="18c37-297">You should be careful when you use these methods, because forcing a string to a uppercase or lowercase is often used as a small normalization for comparing strings regardless of case.</span></span> <span data-ttu-id="18c37-298">その場合は、大文字と小文字を区別しない比較を使用することを検討してください。</span><span class="sxs-lookup"><span data-stu-id="18c37-298">If so, consider using a case-insensitive comparison.</span></span>

<span data-ttu-id="18c37-299"><xref:System.String.ToUpperInvariant%2A?displayProperty=nameWithType> メソッドと <xref:System.String.ToLowerInvariant%2A?displayProperty=nameWithType> メソッドを使用することもできます。</span><span class="sxs-lookup"><span data-stu-id="18c37-299">The <xref:System.String.ToUpperInvariant%2A?displayProperty=nameWithType> and <xref:System.String.ToLowerInvariant%2A?displayProperty=nameWithType> methods are also available.</span></span> <span data-ttu-id="18c37-300"><xref:System.String.ToUpperInvariant%2A> は、大文字と小文字を正規化するための標準的な方法です。</span><span class="sxs-lookup"><span data-stu-id="18c37-300"><xref:System.String.ToUpperInvariant%2A> is the standard way to normalize case.</span></span> <span data-ttu-id="18c37-301"><xref:System.StringComparison.OrdinalIgnoreCase?displayProperty=nameWithType> を使用して行われる比較は、動作の内容を見ると、両方の文字列引数に対して <xref:System.String.ToUpperInvariant%2A> を呼び出し、<xref:System.StringComparison.Ordinal?displayProperty=nameWithType> を使用して比較を行うという、2 つの呼び出しの組み合わせです。</span><span class="sxs-lookup"><span data-stu-id="18c37-301">Comparisons made using <xref:System.StringComparison.OrdinalIgnoreCase?displayProperty=nameWithType> are behaviorally the composition of two calls: calling <xref:System.String.ToUpperInvariant%2A> on both string arguments, and doing a comparison using <xref:System.StringComparison.Ordinal?displayProperty=nameWithType>.</span></span>

<span data-ttu-id="18c37-302">特定のカルチャを表す <xref:System.Globalization.CultureInfo> オブジェクトをメソッドに渡して、そのカルチャで大文字および小文字への変換を行うためのオーバーロードもあります。</span><span class="sxs-lookup"><span data-stu-id="18c37-302">Overloads are also available for converting to uppercase and lowercase in a specific culture, by passing a <xref:System.Globalization.CultureInfo> object that represents that culture to the method.</span></span>

### <a name="chartoupper-and-chartolower"></a><span data-ttu-id="18c37-303">Char.ToUpper と Char.ToLower</span><span class="sxs-lookup"><span data-stu-id="18c37-303">Char.ToUpper and Char.ToLower</span></span>

<span data-ttu-id="18c37-304">既定の解釈: <xref:System.StringComparison.CurrentCulture?displayProperty=nameWithType></span><span class="sxs-lookup"><span data-stu-id="18c37-304">Default interpretation: <xref:System.StringComparison.CurrentCulture?displayProperty=nameWithType>.</span></span>

<span data-ttu-id="18c37-305">これらのメソッドの動作は、上で説明した <xref:System.String.ToUpper%2A?displayProperty=nameWithType> メソッドおよび <xref:System.String.ToLower%2A?displayProperty=nameWithType> メソッドと同様です。</span><span class="sxs-lookup"><span data-stu-id="18c37-305">These methods work similarly to the <xref:System.String.ToUpper%2A?displayProperty=nameWithType> and <xref:System.String.ToLower%2A?displayProperty=nameWithType> methods described in the previous section.</span></span>

### <a name="stringstartswith-and-stringendswith"></a><span data-ttu-id="18c37-306">String.StartsWith と String.EndsWith</span><span class="sxs-lookup"><span data-stu-id="18c37-306">String.StartsWith and String.EndsWith</span></span>

<span data-ttu-id="18c37-307">既定の解釈: <xref:System.StringComparison.CurrentCulture?displayProperty=nameWithType></span><span class="sxs-lookup"><span data-stu-id="18c37-307">Default interpretation: <xref:System.StringComparison.CurrentCulture?displayProperty=nameWithType>.</span></span>

<span data-ttu-id="18c37-308">これらのメソッドは、いずれもカルチャに依存した比較を既定で実行します。</span><span class="sxs-lookup"><span data-stu-id="18c37-308">By default, both of these methods perform a culture-sensitive comparison.</span></span>

### <a name="stringindexof-and-stringlastindexof"></a><span data-ttu-id="18c37-309">String.IndexOf と String.LastIndexOf</span><span class="sxs-lookup"><span data-stu-id="18c37-309">String.IndexOf and String.LastIndexOf</span></span>

<span data-ttu-id="18c37-310">既定の解釈: <xref:System.StringComparison.CurrentCulture?displayProperty=nameWithType></span><span class="sxs-lookup"><span data-stu-id="18c37-310">Default interpretation: <xref:System.StringComparison.CurrentCulture?displayProperty=nameWithType>.</span></span>

<span data-ttu-id="18c37-311">これらのメソッドの既定のオーバーロードは、比較の実行方法が一貫していません。</span><span class="sxs-lookup"><span data-stu-id="18c37-311">There is a lack of consistency in how the default overloads of these methods perform comparisons.</span></span> <span data-ttu-id="18c37-312"><xref:System.Char> パラメーターを含むすべての <xref:System.String.IndexOf%2A?displayProperty=nameWithType> メソッドと <xref:System.String.LastIndexOf%2A?displayProperty=nameWithType> メソッドは、序数に基づく比較を実行します。一方、<xref:System.String> パラメーターを含む既定の <xref:System.String.IndexOf%2A?displayProperty=nameWithType> メソッドと <xref:System.String.LastIndexOf%2A?displayProperty=nameWithType> メソッドは、カルチャに依存した比較を実行します。</span><span class="sxs-lookup"><span data-stu-id="18c37-312">All <xref:System.String.IndexOf%2A?displayProperty=nameWithType> and <xref:System.String.LastIndexOf%2A?displayProperty=nameWithType> methods that include a <xref:System.Char> parameter perform an ordinal comparison, but the default <xref:System.String.IndexOf%2A?displayProperty=nameWithType> and <xref:System.String.LastIndexOf%2A?displayProperty=nameWithType> methods that include a <xref:System.String> parameter perform a culture-sensitive comparison.</span></span>

<span data-ttu-id="18c37-313"><xref:System.String.IndexOf%28System.String%29?displayProperty=nameWithType> メソッドまたは <xref:System.String.LastIndexOf%28System.String%29?displayProperty=nameWithType> メソッドを呼び出して、現在のインスタンスで検索する文字列を渡す場合は、<xref:System.StringComparison> 型を明示的に指定するオーバーロードを呼び出すことをお勧めします。</span><span class="sxs-lookup"><span data-stu-id="18c37-313">If you call the <xref:System.String.IndexOf%28System.String%29?displayProperty=nameWithType> or <xref:System.String.LastIndexOf%28System.String%29?displayProperty=nameWithType> method and pass it a string to locate in the current instance, we recommend that you call an overload that explicitly specifies the <xref:System.StringComparison> type.</span></span> <span data-ttu-id="18c37-314"><xref:System.Char> 引数を含むオーバーロードでは、 <xref:System.StringComparison> 型を指定することはできません。</span><span class="sxs-lookup"><span data-stu-id="18c37-314">The overloads that include a <xref:System.Char> argument do not allow you to specify a <xref:System.StringComparison> type.</span></span>

## <a name="methods-that-perform-string-comparison-indirectly"></a><span data-ttu-id="18c37-315">間接的に文字列比較を実行するメソッド</span><span class="sxs-lookup"><span data-stu-id="18c37-315">Methods that perform string comparison indirectly</span></span>

<span data-ttu-id="18c37-316">文字列比較を中心的な操作とする非文字列メソッドの中には、 <xref:System.StringComparer> 型を使用するものがあります。</span><span class="sxs-lookup"><span data-stu-id="18c37-316">Some non-string methods that have string comparison as a central operation use the <xref:System.StringComparer> type.</span></span> <span data-ttu-id="18c37-317"><xref:System.StringComparer> クラスには、<xref:System.StringComparer> のインスタンスを返す静的プロパティが 6 つ含まれています。これらのインスタンスの <xref:System.StringComparer.Compare%2A?displayProperty=nameWithType> メソッドは、次の種類の文字列比較を実行します。</span><span class="sxs-lookup"><span data-stu-id="18c37-317">The <xref:System.StringComparer> class includes six static properties that return <xref:System.StringComparer> instances whose <xref:System.StringComparer.Compare%2A?displayProperty=nameWithType> methods perform the following types of string comparisons:</span></span>

- <span data-ttu-id="18c37-318">現在のカルチャを使用する、カルチャに依存した文字列比較。</span><span class="sxs-lookup"><span data-stu-id="18c37-318">Culture-sensitive string comparisons using the current culture.</span></span> <span data-ttu-id="18c37-319">この <xref:System.StringComparer> オブジェクトは、<xref:System.StringComparer.CurrentCulture%2A?displayProperty=nameWithType> プロパティによって返されます。</span><span class="sxs-lookup"><span data-stu-id="18c37-319">This <xref:System.StringComparer> object is returned by the <xref:System.StringComparer.CurrentCulture%2A?displayProperty=nameWithType> property.</span></span>
- <span data-ttu-id="18c37-320">現在のカルチャを使用する、大文字と小文字を区別しない比較。</span><span class="sxs-lookup"><span data-stu-id="18c37-320">Case-insensitive comparisons using the current culture.</span></span> <span data-ttu-id="18c37-321">この <xref:System.StringComparer> オブジェクトは、<xref:System.StringComparer.CurrentCultureIgnoreCase%2A?displayProperty=nameWithType> プロパティによって返されます。</span><span class="sxs-lookup"><span data-stu-id="18c37-321">This <xref:System.StringComparer> object is returned by the <xref:System.StringComparer.CurrentCultureIgnoreCase%2A?displayProperty=nameWithType> property.</span></span>
- <span data-ttu-id="18c37-322">インバリアント カルチャの単語ベースの比較規則を使用する、カルチャに依存しない比較。</span><span class="sxs-lookup"><span data-stu-id="18c37-322">Culture-insensitive comparisons using the word comparison rules of the invariant culture.</span></span> <span data-ttu-id="18c37-323">この <xref:System.StringComparer> オブジェクトは、<xref:System.StringComparer.InvariantCulture%2A?displayProperty=nameWithType> プロパティによって返されます。</span><span class="sxs-lookup"><span data-stu-id="18c37-323">This <xref:System.StringComparer> object is returned by the <xref:System.StringComparer.InvariantCulture%2A?displayProperty=nameWithType> property.</span></span>
- <span data-ttu-id="18c37-324">インバリアント カルチャの単語ベースの比較規則を使用する、大文字と小文字を区別しない、カルチャに依存しない比較。</span><span class="sxs-lookup"><span data-stu-id="18c37-324">Case-insensitive and culture-insensitive comparisons using the word comparison rules of the invariant culture.</span></span> <span data-ttu-id="18c37-325">この <xref:System.StringComparer> オブジェクトは、<xref:System.StringComparer.InvariantCultureIgnoreCase%2A?displayProperty=nameWithType> プロパティによって返されます。</span><span class="sxs-lookup"><span data-stu-id="18c37-325">This <xref:System.StringComparer> object is returned by the <xref:System.StringComparer.InvariantCultureIgnoreCase%2A?displayProperty=nameWithType> property.</span></span>
- <span data-ttu-id="18c37-326">序数に基づく比較。</span><span class="sxs-lookup"><span data-stu-id="18c37-326">Ordinal comparison.</span></span> <span data-ttu-id="18c37-327">この <xref:System.StringComparer> オブジェクトは、 <xref:System.StringComparer.Ordinal%2A?displayProperty=nameWithType> プロパティによって返されます。</span><span class="sxs-lookup"><span data-stu-id="18c37-327">This <xref:System.StringComparer> object is returned by the <xref:System.StringComparer.Ordinal%2A?displayProperty=nameWithType> property.</span></span>
- <span data-ttu-id="18c37-328">大文字と小文字を区別しない、序数に基づく比較。</span><span class="sxs-lookup"><span data-stu-id="18c37-328">Case-insensitive ordinal comparison.</span></span> <span data-ttu-id="18c37-329">この <xref:System.StringComparer> オブジェクトは、<xref:System.StringComparer.OrdinalIgnoreCase%2A?displayProperty=nameWithType> プロパティによって返されます。</span><span class="sxs-lookup"><span data-stu-id="18c37-329">This <xref:System.StringComparer> object is returned by the <xref:System.StringComparer.OrdinalIgnoreCase%2A?displayProperty=nameWithType> property.</span></span>

### <a name="arraysort-and-arraybinarysearch"></a><span data-ttu-id="18c37-330">Array.Sort と Array.BinarySearch</span><span class="sxs-lookup"><span data-stu-id="18c37-330">Array.Sort and Array.BinarySearch</span></span>

<span data-ttu-id="18c37-331">既定の解釈: <xref:System.StringComparison.CurrentCulture?displayProperty=nameWithType></span><span class="sxs-lookup"><span data-stu-id="18c37-331">Default interpretation: <xref:System.StringComparison.CurrentCulture?displayProperty=nameWithType>.</span></span>

<span data-ttu-id="18c37-332">データをコレクションに格納したり、永続化されたデータをファイルやデータベースからコレクションに読み取ったりするときに現在のカルチャを切り替えると、コレクション内のインバリアントが無効になる可能性があります。</span><span class="sxs-lookup"><span data-stu-id="18c37-332">When you store any data in a collection, or read persisted data from a file or database into a collection, switching the current culture can invalidate the invariants in the collection.</span></span> <span data-ttu-id="18c37-333"><xref:System.Array.BinarySearch%2A?displayProperty=nameWithType> メソッドでは、配列内で検索する要素が既に並べ替えられていると見なされます。</span><span class="sxs-lookup"><span data-stu-id="18c37-333">The <xref:System.Array.BinarySearch%2A?displayProperty=nameWithType> method assumes that the elements in the array to be searched are already sorted.</span></span> <span data-ttu-id="18c37-334"><xref:System.Array.Sort%2A?displayProperty=nameWithType> メソッドは、配列内の文字列要素を並べ替えるために、<xref:System.String.Compare%2A?displayProperty=nameWithType> メソッドを呼び出して個々の要素を順序付けます。</span><span class="sxs-lookup"><span data-stu-id="18c37-334">To sort any string element in the array, the <xref:System.Array.Sort%2A?displayProperty=nameWithType> method calls the <xref:System.String.Compare%2A?displayProperty=nameWithType> method to order individual elements.</span></span> <span data-ttu-id="18c37-335">配列の並べ替えが行われてから内容の検索が行われるまでの間にカルチャが変更される場合、カルチャに依存した比較子を使用するのは危険です。</span><span class="sxs-lookup"><span data-stu-id="18c37-335">Using a culture-sensitive comparer can be dangerous if the culture changes between the time that the array is sorted and its contents are searched.</span></span> <span data-ttu-id="18c37-336">たとえば、次のコードでは、`Thread.CurrentThread.CurrentCulture` プロパティが暗黙的に指定した比較子で格納と取得の操作が行われます。</span><span class="sxs-lookup"><span data-stu-id="18c37-336">For example, in the following code, storage and retrieval operate on the comparer that is provided implicitly by the `Thread.CurrentThread.CurrentCulture` property.</span></span> <span data-ttu-id="18c37-337">`StoreNames` の呼び出しと `DoesNameExist`の呼び出しの間にカルチャが変更されると (この 2 つのメソッドの呼び出しの間に配列の内容が永続化された場合には特に)、バイナリ サーチが失敗する可能性があります。</span><span class="sxs-lookup"><span data-stu-id="18c37-337">If the culture can change between the calls to `StoreNames` and `DoesNameExist`, and especially if the array contents are persisted somewhere between the two method calls, the binary search may fail.</span></span>

[!code-csharp[Conceptual.Strings.BestPractices#7](~/samples/snippets/csharp/VS_Snippets_CLR/conceptual.strings.bestpractices/cs/indirect1.cs#7)]
 [!code-vb[Conceptual.Strings.BestPractices#7](~/samples/snippets/visualbasic/VS_Snippets_CLR/conceptual.strings.bestpractices/vb/indirect1.vb#7)]

<span data-ttu-id="18c37-338">次の例は、推奨されるバリエーションを示しています。ここでは、配列の並べ替えと検索の両方に、同じ序数に基づく (カルチャに依存しない) 比較メソッドが使用されています。</span><span class="sxs-lookup"><span data-stu-id="18c37-338">A recommended variation appears in the following example, which uses the same ordinal (culture-insensitive) comparison method both to sort and to search the array.</span></span> <span data-ttu-id="18c37-339">コードの変更は、2 つの例の `Line A` および `Line B` というラベルが付いた行に反映されています。</span><span class="sxs-lookup"><span data-stu-id="18c37-339">The change code is reflected in the lines labeled `Line A` and `Line B` in the two examples.</span></span>

[!code-csharp[Conceptual.Strings.BestPractices#8](~/samples/snippets/csharp/VS_Snippets_CLR/conceptual.strings.bestpractices/cs/indirect1.cs#8)]
[!code-vb[Conceptual.Strings.BestPractices#8](~/samples/snippets/visualbasic/VS_Snippets_CLR/conceptual.strings.bestpractices/vb/indirect1.vb#8)]

<span data-ttu-id="18c37-340">このデータを永続化して別のカルチャのシステムに移動したり、データをユーザーに表示するために並べ替えたりする場合は、<xref:System.StringComparison.InvariantCulture?displayProperty=nameWithType> を使用することを検討してください。そうすると、ユーザー出力のために言語的な操作を行っても、カルチャの変更による影響を受けることはありません。</span><span class="sxs-lookup"><span data-stu-id="18c37-340">If this data is persisted and moved across cultures, and sorting is used to present this data to the user, you might consider using <xref:System.StringComparison.InvariantCulture?displayProperty=nameWithType>, which operates linguistically for better user output but is unaffected by changes in culture.</span></span> <span data-ttu-id="18c37-341">次の例では、前の 2 つの例を変更して、配列の並べ替えと検索にインバリアント カルチャを使用しています。</span><span class="sxs-lookup"><span data-stu-id="18c37-341">The following example modifies the two previous examples to use the invariant culture for sorting and searching the array.</span></span>

[!code-csharp[Conceptual.Strings.BestPractices#9](~/samples/snippets/csharp/VS_Snippets_CLR/conceptual.strings.bestpractices/cs/indirect1.cs#9)]
[!code-vb[Conceptual.Strings.BestPractices#9](~/samples/snippets/visualbasic/VS_Snippets_CLR/conceptual.strings.bestpractices/vb/indirect1.vb#9)]

### <a name="collections-example-hashtable-constructor"></a><span data-ttu-id="18c37-342">コレクションの例: Hashtable のコンストラクター</span><span class="sxs-lookup"><span data-stu-id="18c37-342">Collections example: Hashtable constructor</span></span>

<span data-ttu-id="18c37-343">文字列の比較方法の影響を受ける操作の 2 例目は文字列のハッシュです。</span><span class="sxs-lookup"><span data-stu-id="18c37-343">Hashing strings provides a second example of an operation that is affected by the way in which strings are compared.</span></span>

<span data-ttu-id="18c37-344">次の例では、<xref:System.StringComparer.OrdinalIgnoreCase%2A?displayProperty=nameWithType> プロパティから返される <xref:System.StringComparer> オブジェクトを渡して <xref:System.Collections.Hashtable> オブジェクトをインスタンス化しています。</span><span class="sxs-lookup"><span data-stu-id="18c37-344">The following example instantiates a <xref:System.Collections.Hashtable> object by passing it the <xref:System.StringComparer> object that is returned by the <xref:System.StringComparer.OrdinalIgnoreCase%2A?displayProperty=nameWithType> property.</span></span> <span data-ttu-id="18c37-345"><xref:System.StringComparer> から派生するクラス <xref:System.StringComparer> は <xref:System.Collections.IEqualityComparer> インターフェイスを実装するため、その <xref:System.Collections.IEqualityComparer.GetHashCode%2A> メソッドを使用して、ハッシュ テーブルの文字列のハッシュ コードを計算しています。</span><span class="sxs-lookup"><span data-stu-id="18c37-345">Because a class <xref:System.StringComparer> that is derived from <xref:System.StringComparer> implements the <xref:System.Collections.IEqualityComparer> interface, its <xref:System.Collections.IEqualityComparer.GetHashCode%2A> method is used to compute the hash code of strings in the hash table.</span></span>

[!code-csharp[Conceptual.Strings.BestPractices#10](~/samples/snippets/csharp/VS_Snippets_CLR/conceptual.strings.bestpractices/cs/indirect2.cs#10)]
[!code-vb[Conceptual.Strings.BestPractices#10](~/samples/snippets/visualbasic/VS_Snippets_CLR/conceptual.strings.bestpractices/vb/indirect2.vb#10)]

## <a name="see-also"></a><span data-ttu-id="18c37-346">関連項目</span><span class="sxs-lookup"><span data-stu-id="18c37-346">See also</span></span>

- [<span data-ttu-id="18c37-347">.NET アプリでのグローバリゼーション</span><span class="sxs-lookup"><span data-stu-id="18c37-347">Globalization in .NET apps</span></span>](../globalization-localization/globalization.md)
